{
  "version": 3,
  "sources": ["skruv.js"],
  "sourcesContent": ["const htmlNS = 'http://www.w3.org/1999/xhtml'\n/** @type {import(\"./utilityTypes\").keyedMap} */\nconst keyed = new WeakMap()\n/** @type {import(\"./utilityTypes\").oldKeysMap} */\nconst oldKeys = new WeakMap()\n/** @type {import(\"./utilityTypes\").attributesMap} */\nconst attributesMap = new WeakMap()\n/** @type {import(\"./utilityTypes\").domCacheObj} */\nconst domCache = {}\n/**\n * @param {import(\"./utilityTypes\").Vnode} current\n * @param {import(\"./utilityTypes\").AnyRealElement} currentNode\n * @param {ParentNode?} parentNode\n * @param {string} ns\n */\nexport const render = (\n  current,\n  // @ts-expect-error\n  currentNode = globalThis.document.documentElement,\n  // @ts-expect-error\n  parentNode = currentNode.parentNode,\n  ns = htmlNS,\n  forceFull = false\n) => {\n  if (!parentNode) {\n    throw new Error('No parent to render to')\n  }\n  if (typeof current === 'boolean') {\n    // @ts-expect-error\n    if (currentNode) { parentNode.removeChild(currentNode) }\n    return\n  }\n  if (!globalThis?.isSkruvSSR && current?.t?.toLowerCase() === 'skruvtext' && current?.c?.[0]) {\n    current.r = () => {\n      // @ts-expect-error\n      if (!currentNode || !parentNode.contains(currentNode)) { return false }\n      render(current, currentNode, parentNode, ns)\n      return true\n    }\n    // @ts-expect-error\n    render(current?.c?.[0], currentNode)\n    return\n  }\n  const txtNode = (typeof current === 'string' || typeof current === 'number')\n  if (\n    forceFull ||\n    !currentNode ||\n    (txtNode && currentNode.nodeName !== '#text') ||\n    (!txtNode && currentNode.nodeName.toLowerCase() !== current.t.toLowerCase())\n  ) {\n    const _currentNode = currentNode\n    if (txtNode) {\n      // @ts-expect-error: When this is a textnode we will only use it for text, so this should be fine\n      currentNode = document.createTextNode('' + current)\n    } else {\n      if (current.t === 'svg') { ns = 'http://www.w3.org/2000/svg' }\n      if (current.t === 'math') { ns = 'http://www.w3.org/1998/Math/MathML' }\n      if (current.t === 'feed') { ns = 'http://www.w3.org/2005/Atom' }\n      if (current.t === 'urlset' || current.t === 'sitemapindex') { ns = 'https://www.sitemaps.org/schemas/sitemap/0.9' }\n      // @ts-expect-error: All the nodes are actually elements, since the domCache only contains elements\n      currentNode = (domCache[current.t] || (domCache[current.t] = document.createElementNS(ns, current.t))).cloneNode(false)\n    }\n    if (_currentNode) {\n      // @ts-expect-error\n      parentNode.replaceChild(currentNode, _currentNode)\n    } else {\n      // @ts-expect-error\n      parentNode.appendChild(currentNode)\n    }\n    if (txtNode) { return }\n  }\n  if (txtNode) {\n    // We do a loose comparison to allow for numbers\n    // eslint-disable-next-line eqeqeq\n    if (currentNode.textContent != current) { currentNode.textContent = '' + current }\n    return\n  }\n  if (current.r) {\n    current.r = () => {\n      // @ts-expect-error\n      if (!currentNode || !parentNode.contains(currentNode)) { return false }\n      render(current, currentNode, parentNode, ns)\n      return true\n    }\n  }\n  // This needs to come after the .r callback is registered since it should apply to child nodes, not the current node.\n  if (current.t === 'foreignObject') { ns = htmlNS }\n  /** @type {import(\"./utilityTypes\").Vnode[]} */\n  // @ts-expect-error\n  let children = current.c.flat(Infinity)\n  if (!globalThis?.isSkruvSSR) { children = children.filter(c => !c?.t?.startsWith('skruv')) }\n  /** @type {import(\"./utilityTypes\").attributes} */\n  // @ts-expect-error\n  let attributes = {}\n  if (children[0]?.constructor === Object && !children[0]?.isSkruvDom) {\n    // @ts-expect-error\n    attributes = children[0]\n    children = children.slice(1)\n    let oldAttributes = attributesMap.get(currentNode)\n    if (!oldAttributes) {\n      oldAttributes = {}\n      attributesMap.set(currentNode, oldAttributes)\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (('' + oldAttributes[key]) === ('' + value)) { continue }\n      if (key === 'skruvAfterCreate') {\n        // Run after we have processed all the attributes and children\n        setTimeout(() => value(currentNode), 0)\n        oldAttributes[key] = value\n        continue\n      }\n      if (key.startsWith('skruv')) { continue }\n      if (key[0] === 'o' && key[1] === 'n') {\n        const evt = key.slice(2)\n        if (!oldAttributes[key]) {\n          if (oldAttributes[key]) { currentNode.removeEventListener(evt, value) }\n          currentNode.addEventListener(evt, value)\n        } else if (!value) {\n          currentNode.removeEventListener(evt, value)\n        }\n        oldAttributes[key] = value\n        continue\n      }\n      if (\n        (key === 'checked' || key === 'selected' || key === 'value') ||\n        currentNode.nodeName.includes('-') // Support complex data passing for custom elements\n      ) {\n        // @ts-expect-error We have to index the element for custom elements or setting checked/selected/value\n        currentNode[key] = value\n      }\n      if (value !== undefined) {\n        currentNode.setAttribute(key, '' + value)\n      } else {\n        currentNode.removeAttribute(key)\n      }\n      oldAttributes[key] = value\n    }\n  }\n  for (const key of currentNode.getAttributeNames().filter(e => !Object.keys(attributes).includes(e))) {\n    currentNode.removeAttribute(key)\n  }\n  if (!children.length && currentNode.childNodes.length) {\n    if (attributes.skruvWaitForNotEmpty) {\n      return\n    }\n    currentNode.replaceChildren()\n    return\n  }\n  if (currentNode.childNodes.length > children.length) {\n    for (let i = (currentNode.childNodes.length - 1); i >= children.length; i--) {\n      currentNode.removeChild(currentNode.childNodes[i])\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    let forceFull = false\n    /** @type {Element} */\n    let keyedNode\n    if (children[i]?.c) {\n      // @ts-expect-error\n      keyedNode = keyed.get(children[i].c[0]?.skruvKey)\n      if (keyedNode) {\n        // @ts-expect-error\n        if (keyedNode !== currentNode.childNodes[i]) {\n          // @ts-expect-error\n          if (keyedNode === currentNode.childNodes[i + 1]) {\n            currentNode.removeChild(currentNode.childNodes[i])\n          // @ts-expect-error\n          } else if (currentNode.childNodes[i] && keyed.get(children[i + 1]?.c?.[0]?.skruvKey) === currentNode.childNodes[i]) {\n            // @ts-expect-error\n            currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n          } else if (currentNode.childNodes[i]) {\n            // @ts-expect-error\n            currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n          } else {\n            // @ts-expect-error\n            currentNode.appendChild(keyedNode)\n          }\n        }\n        // @ts-expect-error\n        forceFull = children[i].c[0].skruvKey !== oldKeys.get(currentNode.childNodes[i])\n        if (!forceFull) {\n          const lastKeyCopy = keyed.get(currentNode.childNodes[i])\n          if (lastKeyCopy) {\n            let noChange = true\n            // @ts-expect-error\n            for (const k in children[i].c[0].skruvKey) {\n              // @ts-expect-error\n              if (children[i].c[0].skruvKey[k] !== lastKeyCopy[k]) {\n                noChange = false\n              }\n            }\n            if (noChange) { continue }\n          }\n        }\n      } else {\n        forceFull = keyed.has(currentNode.childNodes[i])\n      }\n    }\n    // @ts-expect-error: This will be fine since if the node is of the wrong type a new one is created\n    render(children[i], currentNode.childNodes[i] || false, currentNode, ns, forceFull)\n  }\n  if (attributes.skruvKey) {\n    keyed.set(attributes.skruvKey, currentNode)\n    oldKeys.set(currentNode, attributes.skruvKey)\n    keyed.set(currentNode, { ...attributes.skruvKey })\n  }\n}\n\n/** @type {import(\"./utilityTypes\").ElementMap} */ // @ts-expect-error\nexport const elementFactory = new Proxy({}, { get: (_, t) => (...c) => ({ isSkruvDom: true, t, c }) })\n"],
  "mappings": "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",
  "names": ["htmlNS", "keyed", "oldKeys", "attributesMap", "domCache", "render", "current", "currentNode", "parentNode", "ns", "forceFull", "txtNode", "_currentNode", "children", "c", "attributes", "oldAttributes", "key", "value", "evt", "i", "keyedNode", "lastKeyCopy", "noChange", "k", "elementFactory", "_", "t"]
}
