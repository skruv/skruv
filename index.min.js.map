{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["const s = Symbol.for('skruvDom')\n\nexport const h = (t, ...c) => ({\n    s,\n    t: t.toUpperCase(),\n    ...(\n        typeof c[0] === 'object' &&\n            !Array.isArray(c[0]) &&\n            !(c[0] instanceof Function) &&\n            !(c[0]?.[Symbol.asyncIterator]) &&\n            c[0]?.s !== s\n            ? {\n                a: c[0],\n                c: c.slice(1)\n            }\n            : {\n                a: {},\n                c: c\n            }\n    )\n})\n\nconst keyed = new WeakMap()\n\nconst domCache = {}\n\nexport const render = (\n    current,\n    _currentNode = globalThis.document.documentElement,\n    parentNode = _currentNode?.parentNode,\n    isSvg = false\n) => {\n    let currentNode = _currentNode\n    let childNodes = []\n    let nodeName = currentNode?.nodeName\n    if (!currentNode || (nodeName !== current.t && ((typeof current === 'string' || typeof current === 'number') && nodeName !== '#text'))) {\n        if (typeof current === 'string' || typeof current === 'number') {\n            currentNode = (domCache.text || (domCache.text = parentNode.ownerDocument.createTextNode(''))).cloneNode()\n        } else if (isSvg || current.t === 'svg') {\n            currentNode = (domCache[current.t] || (domCache[current.t] = parentNode.ownerDocument.createElementNS('http://www.w3.org/2000/svg', current.t))).cloneNode()\n        } else {\n            currentNode = (domCache[current.t] || (domCache[current.t] = parentNode.ownerDocument.createElement(current.t))).cloneNode()\n        }\n        if (_currentNode) {\n            parentNode.replaceChild(currentNode, _currentNode)\n        } else {\n            parentNode.appendChild(currentNode)\n        }\n    } else {\n        childNodes = Array.from(currentNode.childNodes)\n    }\n    if (typeof current === 'string' || typeof current === 'number') {\n        if (current.toString() !== currentNode.data.toString()) {\n            currentNode.data = current\n        }\n        return\n    }\n    console.log(_currentNode, current)\n    if(current.s !== s) return\n    for (const key in current.a) {\n        if (key[0] === \"o\" && key[1] === \"n\") {\n            if (!currentNode['data-event-' + key] || currentNode['data-event-' + key]?.toString() !== current.a[key]?.toString()) {\n                if (currentNode['data-event-' + key]) currentNode.removeEventListener(key.slice(2), currentNode['data-event-' + key])\n                currentNode.addEventListener(key.slice(2), current.a[key])\n                currentNode['data-event-' + key] = current.a[key]\n            } else if (!current.a[key]) {\n                currentNode.removeEventListener(key.slice(2), currentNode['data-event-' + key])\n            }\n        } else if (current.a[key] !== currentNode.getAttribute(key)) {\n            if (current.a[key]) {\n                currentNode.setAttribute(key, current.a[key])\n            } else {\n                currentNode.removeAttribute(key)\n            }\n        }\n    }\n    if (!current.c.length && childNodes.length) {\n        currentNode.replaceChildren()\n        return\n    }\n    if (childNodes.length > current.c.length) {\n        for (let i = current.c.length; i < childNodes.length; i++) {\n            currentNode.removeChild(childNodes[i])\n        }\n    }\n    for (let i = 0; i < current.c.length; i++) {\n        if (keyed.has(current.c[i])) {\n            const keyedNode = keyed.get(current.c[i])\n            if (keyedNode !== currentNode.childNodes[i]) {\n                if (keyedNode === currentNode.childNodes[i + 1]) {\n                    currentNode.removeChild(currentNode.childNodes[i])\n                } else if (keyed.has(current.c[i + 1]) && keyed.get(current.c[i + 1]) === currentNode.childNodes[i]) {\n                    currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n                } else if (currentNode.childNodes[i]) {\n                    currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n                } else {\n                    currentNode.appendChild(keyedNode)\n                }\n                keyed.set(current, currentNode)\n            }\n            continue\n        }\n        render(current.c[i], childNodes[i] || false, currentNode, isSvg)\n    }\n    keyed.set(current, currentNode)\n    return\n}\n\nexport const elementFactory = new Proxy({}, { get: (_, name) => (...c) => h(name, ...c) })"],
  "mappings": "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",
  "names": ["s", "h", "c", "_a", "_b", "keyed", "domCache", "render", "current", "_currentNode", "parentNode", "isSvg", "currentNode", "childNodes", "nodeName", "key", "i", "keyedNode", "elementFactory", "_", "name"]
}
