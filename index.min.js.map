{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["/**\n * @typedef {Vnode|string|Boolean|Number|Record<string,(string|boolean|Function|number|Object)> & {_r:{_r:() => boolean}?} & {oncreate:(e: Node) => void}?} SkruvChildNode\n * @typedef {SkruvChildNode[]} SkruvChildNodes\n * @typedef {Record<string,(string|boolean|Function|number|Object)>} VnodeAttributes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {string} t\n * @prop {SkruvChildNodes} c\n * @prop {{_r:() => boolean}} [_r]\n */\nconst s = Symbol.for('skruvDom')\nconst skruvKey = 'data-skruv-key'\n/** @type {WeakMap<Vnode|Node, Node|Object>} */\nconst keyed = new WeakMap()\n/** @type {WeakMap<Node, Object>} */\nconst oldKeys = new WeakMap()\n/** @type {WeakMap<Node, Record<string, function|string|boolean|object>>} */\nconst listenersMap = new WeakMap()\n/** @type {Record<string, Node>} */\nconst domCache = {}\n/**\n * @param {Record<string, any>|Vnode|string|number|boolean} current\n * @param {Node} currentNode\n * @param {ParentNode?} parentNode\n * @param {boolean} isSvg\n */\nexport const render = (\n  current,\n  currentNode = globalThis.document.documentElement,\n  parentNode = currentNode.parentNode,\n  isSvg = false,\n  forceFull = false\n) => {\n  if (!parentNode) {\n    throw new Error('No parent to render to')\n  }\n  if (typeof current === 'boolean') {\n    if (currentNode) { parentNode.removeChild(currentNode) }\n    return\n  }\n  const txtNode = (typeof current === 'string' || typeof current === 'number')\n  if (\n    forceFull ||\n    !currentNode ||\n    (txtNode && currentNode?.nodeName !== '#text') ||\n    (!txtNode && currentNode?.nodeName.toLowerCase() !== current.t.toLowerCase())\n  ) {\n    const _currentNode = currentNode\n    if (txtNode) {\n      currentNode = document.createTextNode('' + current)\n    } else if (isSvg || current.t === 'svg') {\n      isSvg = true\n      currentNode = (domCache[current.t] || (domCache[current.t] = document.createElementNS('http://www.w3.org/2000/svg', current.t))).cloneNode(false)\n    } else {\n      currentNode = (domCache[current.t] || (domCache[current.t] = document.createElement(current.t))).cloneNode(false)\n    }\n    if (_currentNode) {\n      parentNode.replaceChild(currentNode, _currentNode)\n    } else {\n      parentNode.appendChild(currentNode)\n    }\n    if (txtNode) { return }\n  }\n  if (txtNode) {\n    // eslint-disable-next-line eqeqeq\n    if (currentNode.textContent != current) { currentNode.textContent = '' + current }\n    return\n  }\n  if (current._r) {\n    current._r._r = () => {\n      if (!currentNode || !parentNode.contains(currentNode)) { return false }\n      render(current, currentNode, parentNode, isSvg)\n      return true\n    }\n  }\n  let children = current.c.flat(Infinity)\n  /** @type {Record<string, string|boolean|function|object>} */\n  let attributes = {}\n  if (children[0]?.constructor === Object && children[0]?.s !== s) {\n    attributes = children[0]\n    children = children.slice(1)\n    for (const key in attributes) {\n      if (key === skruvKey || key[0] === '_') { continue }\n      if (key[0] === 'o' && key[1] === 'n') {\n        let listeners = listenersMap.get(currentNode)\n        if (!listeners) {\n          listeners = {}\n          listenersMap.set(currentNode, listeners)\n        }\n        const evt = key.slice(2)\n        if (!listeners[key] || ('' + listeners[key]) !== ('' + attributes[key])) {\n          if (evt === 'create') {\n            // @ts-ignore: .on functions should always be callable\n            attributes[key](currentNode)\n            listeners[key] = attributes[key]\n            continue\n          }\n          // @ts-ignore: TODO: TS does not think Function is compatible with EventListenerOrEventListenerObject\n          if (listeners[key]) { currentNode.removeEventListener(evt, listeners[key]) }\n          // @ts-ignore: TODO: TS does not think Function is compatible with EventListenerOrEventListenerObject\n          currentNode.addEventListener(evt, attributes[key])\n          listeners[key] = attributes[key]\n        } else if (!attributes[key]) {\n          // @ts-ignore: TODO: TS does not think Function is compatible with EventListenerOrEventListenerObject\n          currentNode.removeEventListener(evt, listeners[key])\n        }\n        // @ts-ignore: TODO: TS does not like that currentNode \"might\" be a Node here, but since we do checking for text nodes above it is a Element\n      } else if (attributes[key] !== currentNode.getAttribute(key)) {\n        if (\n          (key === 'checked' || key === 'selected' || key === 'value') ||\n          typeof attributes[key] === 'object' // Support complex data passing for custom elements\n        ) {\n          // @ts-ignore: TODO: TS does not like indexing elements with strings, but in this case we need to to set special props. Could be fixed with excessive checking, but that'd slow down perf\n          currentNode[key] = attributes[key]\n        }\n        if (attributes[key]) {\n          // @ts-ignore: TODO: TS does not like that currentNode \"might\" be a Node here, but since we do checking for text nodes above it is a Element\n          currentNode.setAttribute(key, '' + attributes[key])\n        } else {\n          // @ts-ignore: TODO: TS does not like that currentNode \"might\" be a Node here, but since we do checking for text nodes above it is a Element\n          currentNode.removeAttribute(key)\n        }\n      }\n    }\n  }\n  if (!children.length && currentNode.childNodes.length) {\n    if (attributes['data-skruv-wait-for-not-empty']) {\n      return\n    }\n    // @ts-ignore: TODO: TS does not like that currentNode \"might\" be a Node here, but since we do checking for text nodes above it is a Element\n    currentNode.replaceChildren()\n    return\n  }\n  if (currentNode.childNodes.length > children.length) {\n    for (let i = children.length; i < currentNode.childNodes.length; i++) {\n      currentNode.removeChild(currentNode.childNodes[i])\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    let forceFull = false\n    /** @type {Element} */\n    let keyedNode\n    if (children[i].constructor === Object) {\n      // @ts-ignore: A key in the keyed map only points to actual Elements.\n      keyedNode = keyed.get(children[i].c[0]?.[skruvKey])\n      if (keyedNode) {\n        if (keyedNode !== currentNode.childNodes[i]) {\n          if (keyedNode === currentNode.childNodes[i + 1]) {\n            currentNode.removeChild(currentNode.childNodes[i])\n          } else if (currentNode.childNodes[i] && keyed.get(children[i + 1]?.c?.[0]?.[skruvKey]) === currentNode.childNodes[i]) {\n            currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n          } else if (currentNode.childNodes[i]) {\n            currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n          } else {\n            currentNode.appendChild(keyedNode)\n          }\n        }\n        forceFull = children[i].c[0][skruvKey] !== oldKeys.get(currentNode.childNodes[i])\n        if (!forceFull) {\n          const lastKeyCopy = keyed.get(currentNode.childNodes[i])\n          if (lastKeyCopy) {\n            let noChange = true\n            for (const k in children[i].c[0][skruvKey]) {\n              // @ts-ignore: oldKey might be undefinded\n              if (children[i].c[0][skruvKey][k] !== lastKeyCopy[k]) {\n                noChange = false\n              }\n            }\n            if (noChange) { continue }\n          }\n        }\n      } else {\n        forceFull = keyed.has(currentNode.childNodes[i])\n      }\n    }\n    // @ts-ignore: TODO: TS does not like that currentNode \"might\" be a Node here, but since we do checking for text nodes above it is a Element\n    render(children[i], currentNode.childNodes[i] || false, currentNode, isSvg && current.t !== 'foreignObject', forceFull)\n  }\n  if (attributes[skruvKey]) {\n    // @ts-ignore: TODO: The skruvkey is always an object here, but clarify the types for the attributes a bit more\n    keyed.set(attributes[skruvKey], currentNode)\n    oldKeys.set(currentNode, attributes[skruvKey])\n    // @ts-ignore: TODO: The skruvkey is always an object here, but clarify the types for the attributes a bit more\n    keyed.set(currentNode, { ...attributes[skruvKey] })\n  }\n}\n\n/** @type {Record<string, (...c: Array<Record<string, any>|Vnode|string|number|boolean>) => Vnode>} */\nexport const elementFactory = new Proxy({}, { get: (_, t) => (/** @type {Array<Record<string, any>|Vnode|string|number|boolean>} */ ...c) => ({ s, t, c }) })\n\n/**\n * @param {string} t\n * @param  {...Array<Record<string, any>|Vnode|string|number|boolean>} c\n * @returns {Vnode}\n */\n// @ts-ignore: TODO: Check why c is being complained about here\nexport const h = (t, ...c) => ({ s, t, c })\n"],
  "mappings": "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",
  "names": ["s", "skruvKey", "keyed", "oldKeys", "listenersMap", "domCache", "render", "current", "currentNode", "parentNode", "isSvg", "forceFull", "_a", "_b", "_c", "_d", "_e", "_f", "txtNode", "_currentNode", "children", "attributes", "key", "listeners", "evt", "i", "keyedNode", "lastKeyCopy", "noChange", "k", "elementFactory", "_", "t", "c", "h"]
}
