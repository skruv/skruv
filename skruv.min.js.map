{
  "version": 3,
  "sources": ["skruv.js"],
  "sourcesContent": ["const htmlNS = 'http://www.w3.org/1999/xhtml'\n/** @type {import(\"./utilityTypes\").keyedMap} */\nconst keyed = new WeakMap()\n/** @type {import(\"./utilityTypes\").oldKeysMap} */\nconst oldKeys = new WeakMap()\n/** @type {import(\"./utilityTypes\").attributesMap} */\nconst attributesMap = new WeakMap()\n/** @type {import(\"./utilityTypes\").domCacheObj} */\nconst domCache = {}\n/**\n * @param {import(\"./utilityTypes\").Vnode} current\n * @param {import(\"./utilityTypes\").AnyRealElement} currentNode\n * @param {ParentNode?} parentNode\n * @param {string} ns\n */\nexport const render = (\n  current,\n  // @ts-expect-error\n  currentNode = globalThis.document.documentElement,\n  // @ts-expect-error\n  parentNode = currentNode.parentNode,\n  ns = htmlNS,\n  forceFull = false\n) => {\n  if (!parentNode) {\n    throw new Error('No parent to render to')\n  }\n  if (typeof current === 'boolean') {\n    // @ts-expect-error\n    if (currentNode) { parentNode.removeChild(currentNode) }\n    return\n  }\n  const txtNode = (typeof current === 'string' || typeof current === 'number')\n  if (\n    forceFull ||\n    !currentNode ||\n    (txtNode && currentNode.nodeName !== '#text') ||\n    (!txtNode && currentNode.nodeName.toLowerCase() !== current.t.toLowerCase())\n  ) {\n    const _currentNode = currentNode\n    if (txtNode) {\n      // @ts-expect-error: When this is a textnode we will only use it for text, so this should be fine\n      currentNode = document.createTextNode('' + current)\n    } else {\n      if (current.t === 'svg') { ns = 'http://www.w3.org/2000/svg' }\n      if (current.t === 'math') { ns = 'http://www.w3.org/1998/Math/MathML' }\n      if (current.t === 'feed') { ns = 'http://www.w3.org/2005/Atom' }\n      if (current.t === 'urlset' || current.t === 'sitemapindex') { ns = 'https://www.sitemaps.org/schemas/sitemap/0.9' }\n      // @ts-expect-error: All the nodes are actually elements, since the domCache only contains elements\n      currentNode = (domCache[current.t] || (domCache[current.t] = document.createElementNS(ns, current.t))).cloneNode(false)\n    }\n    if (_currentNode) {\n      // @ts-expect-error\n      parentNode.replaceChild(currentNode, _currentNode)\n    } else {\n      // @ts-expect-error\n      parentNode.appendChild(currentNode)\n    }\n    if (txtNode) { return }\n  }\n  if (txtNode) {\n    // We do a loose comparison to allow for numbers\n    // eslint-disable-next-line eqeqeq\n    if (currentNode.textContent != current) { currentNode.textContent = '' + current }\n    return\n  }\n  if (current.r) {\n    current.r = () => {\n      // @ts-expect-error\n      if (!currentNode || !parentNode.contains(currentNode)) { return false }\n      render(current, currentNode, parentNode, ns)\n      return true\n    }\n  }\n  // This needs to come after the .r callback is registered since it should apply to child nodes, not the current node.\n  if (current.t === 'foreignObject') { ns = htmlNS }\n  /** @type {import(\"./utilityTypes\").Vnode[]} */\n  // @ts-expect-error\n  let children = current.c.flat(Infinity)\n  // TODO: SkruvHeader SkruvComment SkruvText\n  if (!globalThis?.isSkruvSSR) { children = children.filter(c => !c?.t?.startsWith('skruv')) }\n  /** @type {import(\"./utilityTypes\").attributes} */\n  // @ts-expect-error\n  let attributes = {}\n  if (children[0]?.constructor === Object && !children[0]?.isSkruvDom) {\n    // @ts-expect-error\n    attributes = children[0]\n    children = children.slice(1)\n    let oldAttributes = attributesMap.get(currentNode)\n    if (!oldAttributes) {\n      oldAttributes = {}\n      attributesMap.set(currentNode, oldAttributes)\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (('' + oldAttributes[key]) === ('' + value)) { continue }\n      if (key === 'skruvKey') { continue }\n      if (key === 'skruvAfterCreate') {\n        // Run after we have processed all the attributes and children\n        setTimeout(() => value(currentNode), 0)\n        oldAttributes[key] = value\n        continue\n      }\n      if (key[0] === 'o' && key[1] === 'n') {\n        const evt = key.slice(2)\n        if (!oldAttributes[key]) {\n          if (oldAttributes[key]) { currentNode.removeEventListener(evt, value) }\n          currentNode.addEventListener(evt, value)\n        } else if (!value) {\n          currentNode.removeEventListener(evt, value)\n        }\n        oldAttributes[key] = value\n        continue\n      }\n      if (\n        (key === 'checked' || key === 'selected' || key === 'value') ||\n        currentNode.nodeName.includes('-') // Support complex data passing for custom elements\n      ) {\n        // @ts-expect-error We have to index the element for custom elements or setting checked/selected/value\n        currentNode[key] = value\n      }\n      if (value !== undefined) {\n        currentNode.setAttribute(key, '' + value)\n      } else {\n        currentNode.removeAttribute(key)\n      }\n      oldAttributes[key] = value\n    }\n  }\n  for (const key of currentNode.getAttributeNames().filter(e => !Object.keys(attributes).includes(e))) {\n    currentNode.removeAttribute(key)\n  }\n  if (!children.length && currentNode.childNodes.length) {\n    if (attributes.skruvWaitForNotEmpty) {\n      return\n    }\n    currentNode.replaceChildren()\n    return\n  }\n  if (currentNode.childNodes.length > children.length) {\n    for (let i = (currentNode.childNodes.length - 1); i >= children.length; i--) {\n      currentNode.removeChild(currentNode.childNodes[i])\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    let forceFull = false\n    /** @type {Element} */\n    let keyedNode\n    if (children[i]?.c) {\n      // @ts-expect-error\n      keyedNode = keyed.get(children[i].c[0]?.skruvKey)\n      if (keyedNode) {\n        // @ts-expect-error\n        if (keyedNode !== currentNode.childNodes[i]) {\n          // @ts-expect-error\n          if (keyedNode === currentNode.childNodes[i + 1]) {\n            currentNode.removeChild(currentNode.childNodes[i])\n          // @ts-expect-error\n          } else if (currentNode.childNodes[i] && keyed.get(children[i + 1]?.c?.[0]?.skruvKey) === currentNode.childNodes[i]) {\n            // @ts-expect-error\n            currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n          } else if (currentNode.childNodes[i]) {\n            // @ts-expect-error\n            currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n          } else {\n            // @ts-expect-error\n            currentNode.appendChild(keyedNode)\n          }\n        }\n        // @ts-expect-error\n        forceFull = children[i].c[0].skruvKey !== oldKeys.get(currentNode.childNodes[i])\n        if (!forceFull) {\n          const lastKeyCopy = keyed.get(currentNode.childNodes[i])\n          if (lastKeyCopy) {\n            let noChange = true\n            // @ts-expect-error\n            for (const k in children[i].c[0].skruvKey) {\n              // @ts-expect-error\n              if (children[i].c[0].skruvKey[k] !== lastKeyCopy[k]) {\n                noChange = false\n              }\n            }\n            if (noChange) { continue }\n          }\n        }\n      } else {\n        forceFull = keyed.has(currentNode.childNodes[i])\n      }\n    }\n    // @ts-expect-error: This will be fine since if the node is of the wrong type a new one is created\n    render(children[i], currentNode.childNodes[i] || false, currentNode, ns, forceFull)\n  }\n  if (attributes.skruvKey) {\n    keyed.set(attributes.skruvKey, currentNode)\n    oldKeys.set(currentNode, attributes.skruvKey)\n    keyed.set(currentNode, { ...attributes.skruvKey })\n  }\n}\n\n/** @type {import(\"./utilityTypes\").ElementMap} */ // @ts-expect-error\nexport const elementFactory = new Proxy({}, { get: (_, t) => (...c) => ({ isSkruvDom: true, t, c }) })\n"],
  "mappings": "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",
  "names": ["htmlNS", "keyed", "oldKeys", "attributesMap", "domCache", "render", "current", "currentNode", "parentNode", "ns", "forceFull", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "txtNode", "_currentNode", "children", "c", "attributes", "oldAttributes", "key", "value", "evt", "e", "i", "keyedNode", "lastKeyCopy", "noChange", "k", "elementFactory", "_", "t"]
}
