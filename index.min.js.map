{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["/* global HTMLInputElement HTMLOptionElement Text Comment HTMLElement SVGElement Document Window */\n\n/**\n * @typedef {Vnode|Function|String|Number|Boolean|SkruvAsyncGenerator|SkruvAsyncIterable|SkruvPromise|SkruvAsyncFunction} SkruvValue\n * @typedef {(AsyncGenerator<Function|String|Boolean|Number>|AsyncIterable<Function|String|Boolean|Number>)} SkruvAttributesIterable\n * @typedef {(Promise<Function|String|Boolean|Number>|function(): Promise<Function|String|Boolean|Number>)} SkruvAttributesPromiseOrAsyncFunction\n * @typedef {Partial<GlobalEventHandlers> & Record<string,(string|boolean|Function|number|Object)>} PreparedVnodeAtrributes\n * @typedef {PreparedVnodeAtrributes & Record<string,(string|boolean|Function|number|Object|SkruvAttributesPromiseOrAsyncFunction|SkruvAttributesIterable)>} VnodeAtrributes\n * @typedef {AsyncGenerator<SkruvValue>} SkruvAsyncGenerator\n * @typedef {AsyncIterable<SkruvValue>} SkruvAsyncIterable\n * @typedef {Promise<SkruvValue>} SkruvPromise\n * @typedef {function(): Promise<SkruvValue>} SkruvAsyncFunction\n * @typedef {Vnode|Vnode[]|SkruvValue} SkruvChildNode\n * @typedef {Array<SkruvChildNode>} SkruvChildNodes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} _c\n * @prop {VnodeAtrributes} _a\n * @prop {{r:() => boolean}} r\n */\n/**\n * @typedef {object} PreparedVnode\n * @prop {Symbol} p\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} _c\n * @prop {VnodeAtrributes} _a\n * @prop {{r:() => boolean}} r\n * @prop {Array<PreparedVnode>} c\n * @prop {PreparedVnodeAtrributes} a\n */\nconst s = Symbol.for('skruvDom')\nconst p = Symbol.for('skruvDomPrepared')\n/** @type {WeakMap<SkruvAsyncGenerator|SkruvAsyncIterable|SkruvPromise|SkruvAsyncFunction|Function|Vnode, SkruvValue?>} */\nconst generatorResults = new WeakMap()\n\n/** @type {WeakMap<Node, Record<string,EventListener?>>} */\nconst skruvListeners = new WeakMap()\n\n/** @type {WeakMap<Object, Node>} */\nconst keyedNodes = new WeakMap()\n\nlet hydrationResolve = () => {}\n/** @type {Promise<void>} */\nconst hydrationPromise = (new Promise(resolve => { hydrationResolve = () => resolve() }))\n\n/** @type {Set<SkruvAsyncGenerator|SkruvAsyncIterable|SkruvPromise|SkruvAsyncFunction|Function|Vnode?>} */\nconst waitingGens = new Set()\n\n// @ts-ignore This is a global set by SSR/Tests\nlet hydrating = globalThis?.SkruvWaitForAsync || !!document.querySelector('data-skruv-ssr-rendered')\n\n/** @type {Vnode} */\nexport const Vnode = { s, t: '', _c: [], _a: {}, r: { r: () => false } }\n\n/** @type {VnodeAtrributes} */\nexport const VnodeAtrributes = {}\n\n/**\n * @param {string} t\n * @param  {Array<SkruvChildNode|VnodeAtrributes>} c\n * @returns {Vnode}\n */\n// @ts-ignore TODO: TS seems to be confused about the spreading of attributes and children. Try separating them\nexport const h = (t, ...c) => ({\n  s,\n  t,\n  ...(\n    typeof c[0] === 'object' &&\n    !Array.isArray(c[0]) &&\n    !(c[0] instanceof Function) && !(c[0] instanceof Function && c[0]?.prototype?.toString?.() === '[object AsyncGenerator]') &&\n    // @ts-ignore How to check for booted generators?\n    !(c[0]?.[Symbol.asyncIterator]) &&\n    // @ts-ignore TODO: check why this still thinks a function can fall though\n    c[0]?.s !== s\n      ? {\n        _a: c[0],\n        _c: c.slice(1)\n      }\n      : {\n        _a: {},\n        _c: c\n      }),\n  r: {\n    r: () => {\n      if (hydrating && !waitingGens.size) {\n        hydrating = false\n        hydrationResolve()\n      }\n      return true\n    }\n  }\n})\n\n// This functions takes in a potentially async value and makes it sync\n/**\n * @param {SkruvValue} value\n * @param  {PreparedVnode} parent\n * @param  {boolean} toVnodes\n * @returns {SkruvValue}\n */\nconst syncify = (value, parent, toVnodes) => {\n  /**\n   *\n   * @param {Function | SkruvAsyncIterable | SkruvPromise | Vnode} value\n   * @param {string | number | boolean | Function | Vnode | SkruvAsyncIterable | SkruvPromise | null} result\n   * @returns\n   */\n  const process = (value, result) => {\n    // @ts-ignore optional chaining\n    if (hydrating && result?._a?.['data-skruv-finished'] !== false) {\n      waitingGens.delete(value)\n      // Make sure any async calls that returned other async nodes get added to the hydration queue\n      if (result) {\n        // @ts-ignore vdom typeguard\n        if (result?.s === s) { flatten(result) } else { syncify(result, parent, toVnodes) }\n      }\n    }\n    generatorResults.set(value, result)\n    return parent.r.r()\n  }\n  // @ts-ignore maybe stricten up checks here\n  if (generatorResults.has(value)) { return generatorResults.get(value) }\n  // @ts-ignore TODO: Check what is the right way to detect started asynciterators\n  if (typeof value === 'object' && value?.[Symbol.asyncIterator]) {\n    const val = (/** @type {SkruvAsyncIterable} */ (value))\n    if (hydrating) { waitingGens.add(val) }\n    generatorResults.set(val, null);\n    (async () => { for await (const result of val) { if (!process(value, result)) { break } } })()\n    return false\n  } else if (value instanceof Function && value?.prototype?.toString?.() === '[object AsyncGenerator]') {\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(value, null);\n    (async () => { for await (const result of value()) { if (!process(value, result)) { break } } })()\n    return false\n    // @ts-ignore TODO: .then might not exist, but thats why I'm checking it!\n  } else if (typeof value === 'object' && value !== null && value?.then instanceof Function) {\n    const val = (/** @type {SkruvPromise} */ (value))\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(val, null);\n    (async () => { process(val, await val) })()\n    return false\n  } else if (typeof value === 'function' && value.constructor.name === 'AsyncFunction') {\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(value, null);\n    (async () => { process(value, await value()) })()\n    return false\n  } else if (typeof value === 'function') {\n    if (toVnodes) {\n      return value()\n    }\n    return value\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    if (toVnodes) {\n      return h('#text', { data: value.toString() })\n    }\n    return value.toString()\n  } else if (typeof value === 'boolean') {\n    return value\n  }\n  throw new Error('Unkown type in syncify: ' + JSON.stringify(value))\n}\n\n/**\n *\n * @param {SkruvChildNodes} c\n * @param {Vnode} skruvDom\n * @returns {PreparedVnode[]}\n */\nconst recurseVnodes = (c, skruvDom) => {\n  const newVnodes = c.flat(Infinity)\n    // @ts-ignore TS does not understand that .s is a typeguard for vnodes\n    .map(value => value?.s === s ? flatten(value) : syncify(value, skruvDom, true))\n    .flat(Infinity)\n    .filter(value => value !== null && typeof value !== 'boolean' && typeof value !== 'undefined')\n  // @ts-ignore Optional chaining\n  if (newVnodes.find(value => value?.p !== p) !== undefined) {\n    return recurseVnodes(newVnodes, skruvDom)\n  }\n  // @ts-ignore We already guard against this with the .p check above\n  return newVnodes\n}\n\n// This needs all sorts of cleanup\n// TODO: Instead of modifying the object have the r function be an object ({r:()=>}) so you can replace the inner function without having to modify the original\n/**\n * @param {Vnode} skruvDom\n * @returns {PreparedVnode}\n */\nconst flatten = skruvDom => {\n  const a = Object.fromEntries(\n    Object.entries(skruvDom._a)\n      .filter(entry => entry[1] !== null && typeof entry[1] !== 'undefined')\n      // @ts-ignore We already check null above\n      .map(([key, value]) => key === 'data-skruv-key' ? [key, value] : [key, syncify(value, skruvDom, false)])\n      .filter(entry => entry[1] !== null && typeof entry[1] !== 'undefined')\n  )\n  return {\n    p,\n    ...skruvDom,\n    a,\n    c: recurseVnodes(skruvDom._c, skruvDom)\n  }\n}\n\n/**\n * @param {PreparedVnode} current\n * @param {Element} currentNode\n * @param {ParentNode?} parentNode\n * @param {boolean} isSvg\n */\nconst renderRecursive = (current, currentNode, parentNode, isSvg) => {\n  if (current.p !== p) {\n    throw new Error('unkown type in render: ' + JSON.stringify(current))\n  }\n  for (const c of current.c) {\n    if (c.p !== p) {\n      throw new Error('unkown type in render: ' + JSON.stringify(c))\n    }\n  }\n  if (!parentNode || (currentNode && !parentNode.contains(currentNode))) { return false }\n  const ownerDocument = currentNode.ownerDocument\n  const documentElement = ownerDocument.documentElement\n\n  for (const key of currentNode.getAttributeNames().filter(k => !Object.keys(current.a).includes(k))) {\n    currentNode.removeAttribute(key)\n  }\n\n  for (const [key, value] of Object.entries(current.a)) {\n    if (key === 'data-skruv-key') { continue }\n    /** @type {EventListenerOrEventListenerObject} */\n    if (key.slice(0, 2) === 'on') {\n      let listeners = skruvListeners.get(currentNode)\n      const curr = listeners?.[key]\n      const event = key.slice(2)\n      if (!listeners) {\n        listeners = {}\n        skruvListeners.set(currentNode, listeners)\n      }\n      if (value instanceof Function) {\n        if (curr && curr.toString() !== value.toString()) {\n          currentNode.removeEventListener(event, curr)\n          listeners[key] = null\n        }\n        if (!curr) {\n          // @ts-ignore EventListener and Function are incompatible according to TS\n          listeners[key] = value\n          // @ts-ignore EventListener and Function are incompatible according to TS\n          currentNode.addEventListener(event, value)\n        }\n        continue\n      }\n      if (curr && !value) {\n        currentNode.removeEventListener(event, curr)\n        listeners[key] = null\n      }\n    }\n    if (value === null || value === false) {\n      if (currentNode.getAttribute(key)) {\n        currentNode.removeAttribute(key)\n      }\n      continue\n    }\n    currentNode.setAttribute(key, value.toString())\n    if (key === 'value' && (typeof value === 'number' || typeof value === 'string') && currentNode instanceof HTMLInputElement) {\n      currentNode[key] = value.toString()\n    }\n    if (\n      (\n        typeof value === 'boolean' &&\n        (\n          (currentNode instanceof HTMLInputElement && key === 'checked') ||\n          (currentNode instanceof HTMLOptionElement && key === 'selected')\n        )\n      ) || typeof value === 'object' // Support complex data passing for custom elements\n    ) {\n      // @ts-ignore TS does not think HTML properties are accessible directly?\n      currentNode[key] = value\n    }\n  }\n\n  current.r.r = () => renderRecursive(flatten(current), currentNode, parentNode, isSvg)\n\n  if (current.a['data-skruv-opaque']) {\n    return true\n  }\n\n  // Reuse of old nodes and handle keying\n  const prev = Array.from(currentNode.childNodes)\n  const curr = current.c\n  /** @type {Array<Node?>} */\n  const newOrder = []\n  /**\n   * @param {ChildNode} p\n   * @param {Vnode} c\n   * @returns {boolean}\n   */\n  const comp = (p, c) => p.nodeName.toLowerCase() === c.t && !newOrder.includes(p)\n  for (let ci = 0; ci < curr.length; ci++) {\n    const c = curr[ci]\n    const inPrev = c.a['data-skruv-key'] ? keyedNodes.get(c.a['data-skruv-key']) : prev.find(p => comp(p, c))\n    if (inPrev) {\n      newOrder[ci] = inPrev\n    } else {\n      newOrder[ci] = null\n    }\n  }\n  const toRemove = prev.filter(p => !newOrder.includes(p))\n\n  if (current.c.length || !current.a['data-skruv-wait-for-not-empty']) {\n    for (const elem of toRemove.filter(e => !!e)) {\n      currentNode.removeChild(elem)\n      // We have to do a microsleep before check since keyed nodes could have been moved to another location\n      setTimeout(() => {\n        if (!documentElement?.contains(elem) && skruvListeners.get(elem)?.onremove) { elem.dispatchEvent(new CustomEvent('remove')) }\n      }, 1)\n    }\n  }\n\n  for (let i = 0; i < newOrder.length; i++) {\n    const child = current.c[i]\n    let created = false\n    if (!newOrder[i]) {\n      let newChild\n      if (current.t === '#comment') {\n        newChild = ownerDocument.createComment('')\n      } else if (child.t === '#text') {\n        newChild = ownerDocument.createTextNode('')\n      } else if (child.p === p && (isSvg || child.t === 'svg')) {\n        newChild = ownerDocument.createElementNS('http://www.w3.org/2000/svg', child.t)\n      } else {\n        newChild = ownerDocument.createElement(child.t)\n      }\n      created = true\n      if (currentNode.childNodes[i]) {\n        currentNode.replaceChild(newChild, currentNode.childNodes[i])\n      } else if (i === 0) {\n        currentNode.prepend(newChild)\n      } else {\n        currentNode.childNodes[i - 1].after(newChild)\n      }\n    } else if (newOrder[i] !== currentNode.childNodes[i]) {\n      // Make ts happy\n      const nodeToMove = newOrder[i]\n      if (nodeToMove) {\n        if (i === 0) {\n          currentNode.prepend(nodeToMove)\n        } else {\n          currentNode.childNodes[i - 1].after(nodeToMove)\n        }\n      }\n    }\n    const childNode = currentNode.childNodes[i]\n    if ((childNode instanceof Text || childNode instanceof Comment)) {\n      if (childNode.data !== child.a.data) { childNode.data = child.a.data.toString() }\n      // Comment and text nodes have no attributes or children so bail here\n      continue\n    }\n    if (!(childNode instanceof HTMLElement || childNode instanceof SVGElement)) {\n      throw new Error('Child node of unknown type: ' + JSON.stringify({ childNode, child }))\n    }\n    if (child.a['data-skruv-key'] && !keyedNodes.has(child.a['data-skruv-key'])) { keyedNodes.set(child.a['data-skruv-key'], childNode) }\n    renderRecursive(child, childNode, currentNode, isSvg || current.t === 'svg')\n    if (created && skruvListeners.get(childNode)?.oncreate) { childNode.dispatchEvent(new CustomEvent('create')) }\n  }\n  return true\n}\n\n/**\n * @param {Vnode} current\n * @param {Element} [currentNode]\n * @param {ParentNode?} parentNode\n * @param {boolean} [isSvg]\n */\nexport const render = async (\n  current,\n  currentNode = document.documentElement,\n  parentNode = currentNode?.parentNode,\n  isSvg = false\n) => {\n  if (!parentNode) {\n    // TODO: create error classes for skruv, inherit from one single error class\n    throw new Error('Skruv: No parent to render to')\n  }\n  if (!(parentNode instanceof HTMLElement || parentNode instanceof SVGElement || parentNode instanceof Document || parentNode instanceof Window)) {\n    // TODO: create error classes for skruv, inherit from one single error class\n    throw new Error('Skruv: Parent of wrong type')\n  }\n  if (hydrating) {\n    // If we are hydrating we first do a pass to find all async nodes, resolve those and then do a full render\n    flatten(current).r.r()\n    await hydrationPromise\n  }\n  renderRecursive(flatten(current), currentNode, parentNode, isSvg)\n}\n\n/** @type {Record<string, ((...c: Array<SkruvChildNode|VnodeAtrributes>) => Vnode)>} */\nconst proxyBase = {}\nexport const htmlFactory = new Proxy(\n  proxyBase,\n  { get: (_target, /** @type {string} */name) => /** @param {Array<SkruvChildNode|VnodeAtrributes>} c */(...c) => h(name, ...c) }\n)\n"],
  "mappings": "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",
  "names": ["s", "p", "generatorResults", "skruvListeners", "keyedNodes", "hydrationResolve", "hydrationPromise", "resolve", "waitingGens", "hydrating", "Vnode", "VnodeAtrributes", "h", "c", "_a", "_b", "_c", "_d", "_e", "syncify", "value", "parent", "toVnodes", "process", "result", "flatten", "val", "recurseVnodes", "skruvDom", "newVnodes", "a", "entry", "key", "renderRecursive", "current", "currentNode", "parentNode", "isSvg", "ownerDocument", "documentElement", "k", "listeners", "curr", "event", "prev", "newOrder", "comp", "ci", "inPrev", "toRemove", "elem", "e", "i", "child", "created", "nodeToMove", "newChild", "childNode", "render", "proxyBase", "htmlFactory", "_target", "name"]
}
