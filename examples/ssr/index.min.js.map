{
  "version": 3,
  "sources": ["../../index.js", "../../utils/css.js", "../../utils/state.js", "../../utils/syncify.js", "index.js"],
  "sourcesContent": ["const s = Symbol.for('skruvDom')\nconst eventPrefix = 'data-event-'\n/**\n * @typedef {Vnode|Vnode[]|String|Boolean|Number} SkruvChildNode\n * @typedef {SkruvChildNode[]} SkruvChildNodes\n * @typedef {Record<string,(string|boolean|Function|number|Object)>} VnodeAttributes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} c\n * @prop {Record<string,(string|boolean|Function|number|Object)> & {_r:{_r:() => boolean}?}} a\n * @prop {{_r:() => boolean}} [_r]\n */\n/**\n * @param {string} t\n * @param  {(Record<string, any>|Vnode)[]} c\n * @returns {Vnode}\n */\n// @ts-ignore: TODO: The check for non-attribute objects does not satisfy TS\nexport const h = (t, ...c) => ({\n  s,\n  t: t.toUpperCase(),\n  ...(\n    // @ts-ignore: its exactly because we don't know if its there that we check it\n    !(c[0]?.[Symbol.asyncIterator]) &&\n        c[0]?.constructor === Object &&\n      c[0]?.s !== s\n      ? {\n        a: c[0],\n        c: c.slice(1)\n      }\n      : {\n        a: {},\n        c: c\n      }\n  )\n})\n\n/** @type {WeakMap<Vnode, Node>} */\nconst keyed = new WeakMap()\n/** @type {Record<string, Node>} */\nconst domCache = {}\n/**\n * @param {Vnode} current\n * @param {Node} _currentNode\n * @param {ParentNode?} parentNode\n * @param {*} isSvg\n * @returns {boolean}\n */\nexport const render = (\n  current,\n  _currentNode = globalThis.document.documentElement,\n  parentNode = _currentNode.parentNode,\n  isSvg = false\n) => {\n  let currentNode = _currentNode\n  const doc = parentNode?.ownerDocument || currentNode.ownerDocument\n  if (!parentNode || !doc || (currentNode && !parentNode.contains(currentNode))) { return false }\n  if (typeof current === 'boolean' || current === null || current === undefined) {\n    if (currentNode) { parentNode.removeChild(currentNode) }\n    return true\n  }\n  if (\n    ((typeof current === 'string' || typeof current === 'number') && currentNode?.nodeName !== '#text') ||\n    (current?.t && currentNode?.nodeName !== current?.t) ||\n    // @ts-ignore: Check for keying\n    (currentNode?.getAttribute?.('data-skruv-key') && currentNode?.getAttribute?.('data-skruv-key') !== current?.a?.['data-skruv-key'])\n  ) {\n    if (typeof current === 'string' || typeof current === 'number') {\n      currentNode = (domCache.text || (domCache.text = doc.createTextNode(''))).cloneNode()\n    } else if (isSvg || current.t === 'svg') {\n      currentNode = (domCache[current.t] || (domCache[current.t] = doc.createElementNS('http://www.w3.org/2000/svg', current.t))).cloneNode()\n    } else {\n      currentNode = (domCache[current.t] || (domCache[current.t] = doc.createElement(current.t))).cloneNode()\n    }\n    if (_currentNode) {\n      parentNode.replaceChild(currentNode, _currentNode)\n    } else {\n      parentNode.appendChild(currentNode)\n    }\n    // @ts-ignore: oncreate should always be callable. TODO: add strict typing\n    if (current?.a?.oncreate) { current.a.oncreate(currentNode) }\n  }\n  if ((typeof current === 'string' || typeof current === 'number')) {\n    // @ts-ignore: We already checked this above. It's not 'never'\n    if (('' + currentNode.data) !== ('' + current)) { currentNode.data = current }\n    return true\n  }\n  if (current._r) { current._r._r = () => render(current, currentNode, parentNode, isSvg) }\n  for (const key in current.a) {\n    if (key[0] === 'o' && key[1] === 'n') {\n      const evt = key.slice(2)\n      // @ts-ignore: TODO: this is a hacky way to store what the last eventlistener was\n      if (!currentNode[eventPrefix + key] || ('' + currentNode[eventPrefix + key]) !== ('' + current.a[key])) {\n        // @ts-ignore: See above\n        if (currentNode[eventPrefix + key]) { currentNode.removeEventListener(evt, currentNode[eventPrefix + key]) }\n        // @ts-ignore: See above\n        currentNode.addEventListener(evt, current.a[key])\n        // @ts-ignore: See above\n        currentNode[eventPrefix + key] = current.a[key]\n      } else if (!current.a[key]) {\n        // @ts-ignore: data-event-* is the old function\n        currentNode.removeEventListener(evt, currentNode[eventPrefix + key])\n      }\n    // @ts-ignore: If this was a text or comment element we would have returned above\n    } else if (current.a[key] !== currentNode.getAttribute(key)) {\n      if (\n        (\n          typeof current.a[key] === 'boolean' &&\n          (\n            (current.t === 'INPUT' && key === 'checked') ||\n            (current.t === 'OPTION' && key === 'selected')\n          )\n        ) || typeof current.a[key] === 'object' // Support complex data passing for custom elements\n      ) {\n        // @ts-ignore TS does not think HTML properties are accessible directly?\n        currentNode[key] = current.a[key]\n      }\n      if (current.a[key]) {\n        // @ts-ignore: If this was a text or comment element we would have returned above\n        currentNode.setAttribute(key, '' + current.a[key])\n      } else {\n        // @ts-ignore: If this was a text or comment element we would have returned above\n        currentNode.removeAttribute(key)\n      }\n    }\n  }\n  const children = current.c.flat(Infinity)\n  if (!children.length && currentNode.childNodes.length) {\n    if (current.a['data-skruv-wait-for-not-empty']) {\n      return true\n    }\n    // @ts-ignore: If this was a text or comment element we would have returned above\n    currentNode.replaceChildren()\n    return true\n  }\n  if (currentNode.childNodes.length > children.length) {\n    for (let i = children.length; i < currentNode.childNodes.length; i++) {\n      currentNode.removeChild(currentNode.childNodes[i])\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    // @ts-ignore: TODO: the flattening seems to confuse TS\n    if (keyed.has(children[i])) {\n      // @ts-ignore: See above\n      const keyedNode = keyed.get(children[i])\n      if (keyedNode !== currentNode.childNodes[i]) {\n        if (keyedNode === currentNode.childNodes[i + 1]) {\n          currentNode.removeChild(currentNode.childNodes[i])\n        // @ts-ignore: See above\n        } else if (keyed.has(children[i + 1]) && keyed.get(children[i + 1]) === currentNode.childNodes[i]) {\n          // @ts-ignore\n          currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n        } else if (currentNode.childNodes[i]) {\n          // @ts-ignore\n          currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n        } else {\n          // @ts-ignore\n          currentNode.appendChild(keyedNode)\n        }\n        // @ts-ignore: See above\n        keyed.set(children[i], currentNode.childNodes[i])\n      }\n      continue\n    }\n    // @ts-ignore: See above\n    render(children[i], currentNode.childNodes[i] || false, currentNode, isSvg)\n  }\n  keyed.set(current, currentNode)\n  return true\n}\n\nexport const elementFactory = new Proxy({}, {\n  /** @type {(_: any, name: string) => (arg0: (Record<string, any>|Vnode)[]) => Vnode} */\n  get: (_, name) => (...c) => h(name, ...c)\n})\n", "/* global CSSMediaRule CSSStyleRule CSSOM */\n\n// TODO: package\n/** @type {function} */\nlet resolveStyles = () => {}\nlet promiseStyles = new Promise(resolve => { resolveStyles = resolve })\nconst styleMap = new Map()\n\n// // Example of using webcrypto for hashing. Only works if loaded over https, so not used. Also requires async\n// const encoder = new TextEncoder()\n// /**\n//  * @param {string} str\n//  * @returns {Promise<string>}\n//  */\n// const hash = async str => [...new Uint8Array(await crypto.subtle.digest('SHA-1', encoder.encode(str)))].map(x => x.toString(16).padStart(2, '0')).join('')\n\n/**\n * @param {string} str\n * @returns {string}\n */\nconst hash = str => {\n  let hash = 0\n  if (str.length === 0) { return hash.toString() }\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) - hash) + str.charCodeAt(i)\n    hash |= 0 // Convert to 32bit integer\n  }\n  return hash.toString()\n}\n\n/**\n * Scoped CSS helper\n * @param {TemplateStringsArray} strings\n * @param {(String | Number | Boolean | undefined)[]} keys\n * @returns {string}\n */\nexport const css = (strings, ...keys) => {\n  const stylesheet = strings.reduce(\n    /**\n     * @param {String[]} prev\n     * @param {String} curr\n     * @returns {String[]}\n     */\n    (prev, curr, i) => {\n      prev.push(curr)\n      prev.push(keys?.[i]?.toString() || '')\n      return prev\n    },\n    []\n  ).join('')\n\n  // The implementation of this is lifted from https://github.com/samthor/scoped with some modifications\n  const attrRe = /^\\[.*?(?:([\"'])(?:.|\\\\\\1)*\\1.*)*\\]/\n  const walkSelectorRe = /([([,]|:scope\\b)/ // \"interesting\" setups\n  const scopeRe = /^:scope\\b/\n\n  /**\n   * Consumes a single selector from candidate selector text, which may contain many.\n   *\n   * @param {string} raw selector text\n   * @param {string} prefix prefix to apply\n   * @return {?{selector: string, rest: string}}\n   */\n  function consumeSelector (raw, prefix) {\n    let i = raw.search(walkSelectorRe)\n    if (i === -1) {\n      // found literally nothing interesting, success\n      return {\n        selector: `${prefix} ${raw}`,\n        rest: ''\n      }\n    } else if (raw[i] === ',') {\n      // found comma without anything interesting, yield rest\n      return {\n        selector: `${prefix} ${raw.substring(0, i)}`,\n        rest: raw.substring(i + 1)\n      }\n    }\n\n    let leftmost = true // whether we're past a descendant or similar selector\n    let scope = false // whether :scope has been found + replaced\n    i = raw.search(/\\S/) // place i after initial whitespace only\n\n    let depth = 0\n    // eslint-disable-next-line no-labels\n    outer:\n    for (; i < raw.length; ++i) {\n      const char = raw[i]\n      switch (char) {\n        case '[': {\n          const match = attrRe.exec(raw.substring(i))\n          i += (match ? match[0].length : 1) - 1 // we add 1 every loop\n          continue\n        }\n        case '(':\n          ++depth\n          continue\n        case ':':\n          if (!leftmost) {\n            continue // doesn't matter if :scope is here, it'll always be ignored\n          } else if (!scopeRe.test(raw.substring(i))) {\n            continue // not ':scope', ignore\n          } else if (depth) {\n            return null\n          }\n          // Replace ':scope' with our prefix. This can happen many times; ':scope:scope' is valid.\n          // It will never apply to a descendant selector (e.g., \".foo :scope\") as this is ignored\n          // by browsers anyway (invalid).\n          raw = raw.substring(0, i) + prefix + raw.substring(i + 6)\n          i += prefix.length\n          scope = true\n          --i // we'd skip over next character otherwise\n          continue // run loop again\n        case ')':\n          if (depth) {\n            --depth\n          }\n          continue\n      }\n      if (depth) {\n        continue\n      }\n\n      switch (char) {\n        case ',':\n          // eslint-disable-next-line no-labels\n          break outer\n        case ' ':\n        case '>':\n        case '~':\n        case '+':\n          if (!leftmost) {\n            continue\n          }\n          leftmost = false\n      }\n    }\n\n    const selector = (scope ? '' : `${prefix} `) + raw.substring(0, i)\n    return { selector, rest: raw.substring(i + 1) }\n  }\n\n  /**\n   * @param {string} selectorText\n   * @param {string} prefix to apply\n   */\n  function updateSelectorText (selectorText, prefix) {\n    const found = []\n\n    while (selectorText) {\n      const consumed = consumeSelector(selectorText, prefix)\n      if (consumed === null) {\n        return ':not(*)'\n      }\n      found.push(consumed.selector)\n      selectorText = consumed.rest\n    }\n\n    return found.join(', ')\n  }\n\n  /**\n   * Upgrades a specific CSSRule.\n   *\n   * @param {!CSSRule} rule\n   * @param {string} prefix to apply\n   */\n  function upgradeRule (rule, prefix) {\n    if (rule instanceof CSSMediaRule) {\n      // upgrade children\n      const l = rule.cssRules.length\n      for (let j = 0; j < l; ++j) {\n        upgradeRule(rule.cssRules[j], prefix)\n      }\n      return\n    }\n\n    if (!(rule instanceof CSSStyleRule)) {\n      return // unknown rule type, ignore\n    }\n\n    rule.selectorText = updateSelectorText(rule.selectorText, prefix)\n  }\n  const scope = hash(stylesheet)\n  const retval = `skruv-css-scope-${scope}`\n  const prefix = `.${retval}`\n\n  if (styleMap.has(scope)) {\n    return retval\n  }\n  let sheet\n  // @ts-ignore TODO: If we don't have any way to parse the css bail out\n  if (!globalThis?.CSSOM && !globalThis.document?.implementation) {\n    throw new Error('No css parser available. Either add CSSOM to globalThis or run in browser.')\n  }\n  // @ts-ignore: TODO: Type confusion between polyfill and native.\n  if (globalThis?.CSSOM) {\n    // @ts-ignore: TODO: Type confusion between polyfill and native.\n    sheet = CSSOM.parse(stylesheet)\n  } else {\n    // In FF/Chrome we could create the sheet with new CSSStyleSheet(), but that does not work in safari (supported from 16.4 (Released 2023-03-27))\n    // TODO: don't recreate each run\n    const styleDoc = globalThis.document.implementation.createHTMLDocument('')\n    const styleElem = styleDoc.createElement('style')\n    styleElem.innerText = stylesheet\n    styleDoc.body.append(styleElem)\n    sheet = styleElem.sheet\n    styleDoc.body.removeChild(styleElem)\n  }\n  Array.from(sheet?.cssRules || []).forEach(e =>\n    // @ts-ignore: TODO: Type confusion between polyfill and native.\n    upgradeRule(e, prefix)\n  )\n  const upgradedStyles = Array.from(sheet?.cssRules || []).map(e =>\n    e.cssText || ''\n  )\n    .join('')\n  styleMap.set(scope, upgradedStyles)\n  resolveStyles()\n  return retval\n}\n\n/**\n * @returns {AsyncGenerator<string>}\n */\nexport async function * cssTextGenerator () {\n  yield Array.from(styleMap.values()).join('')\n  while (true) {\n    await promiseStyles\n    yield Array.from(styleMap.values()).join('')\n    promiseStyles = new Promise(resolve => { resolveStyles = resolve })\n  }\n}\n", "// @ts-nocheck\n// TODO: This file will be hard to typecheck without generic types, check how to do it with TS later\nconst resolveTimer = globalThis?.requestAnimationFrame || (cb => setTimeout(cb, 0))\n\nexport const createState = stateObj => {\n  const Handler = class Handler {\n    constructor (name) {\n      this.name = name\n      this._scheduled = false\n      this._skruv_promise = new Promise(resolve => { this._skruv_resolve = resolve })\n    }\n\n    _resolve () {\n      if (this._skruv_parent && this._skruv_parent._resolve) {\n        this._skruv_parent._resolve()\n      }\n      if (this._scheduled) { return }\n      this._scheduled = true\n      resolveTimer(() => {\n        this._skruv_resolve()\n        this._skruv_promise = new Promise(resolve => { this._skruv_resolve = resolve })\n        this._scheduled = false\n      })\n    }\n\n    set (target, key, value) {\n      if (key === '_skruv_parent') {\n        this._skruv_parent = value\n        return true\n      }\n      if (target[key] !== value) {\n        target[key] = this.recurse(key, value, target)\n      }\n      return true\n    }\n\n    get (target, key, proxy) {\n      if (key === 'getGenerator') {\n        return key => ({\n          key: [key, target],\n          [Symbol.asyncIterator]: () => {\n            // If this is the first loop for this sub we should return directly for first value\n            let booted = false\n            return {\n              next: async () => {\n                if (booted) {\n                  await this._skruv_promise\n                } else {\n                  booted = true\n                }\n                return { done: false, value: proxy[key] }\n              }\n            }\n          }\n        })\n      }\n      if (key === 'skruv_resolve') {\n        return () => this._resolve()\n      }\n      if (key === 'toJSON') {\n        if (target.constructor === Object) {\n          return Object.getOwnPropertyNames(target).reduce((acc, curr) => {\n            acc[curr] = target[curr]?.toJSON || target[curr]\n            return acc\n          }, {})\n        }\n        if (target.constructor === Array) {\n          return target.map(curr => curr?.toJSON || curr)\n        }\n        return target\n      }\n      if (key === Symbol.asyncIterator) {\n        return () => {\n          // If this is the first loop for this sub we should return directly for first value\n          let booted = false\n          return {\n            next: async () => {\n              if (booted) {\n                await this._skruv_promise\n              } else {\n                booted = true\n              }\n              return { done: false, value: proxy }\n            }\n          }\n        }\n      }\n      return target[key]\n    }\n\n    deleteProperty (target, key) {\n      const res = delete target[key]\n      this._resolve()\n      return res\n    }\n\n    recurse (path, value, target) {\n      // check for falsy values\n      if (value && value.constructor) {\n        if (value.constructor === Object && target?.[path]?.constructor === Object) {\n          for (const key of Object.getOwnPropertyNames(value)) {\n            if (target[path][key] !== value[key]) {\n              target[path][key] = value[key]\n            }\n          }\n          for (const key of Object.getOwnPropertyNames(target[path])\n            .filter(item => !Object.getOwnPropertyNames(value).includes(item))\n          ) {\n            delete target[path][key]\n            this._resolve()\n          }\n          return target[path]\n        } else if (value.constructor === Object) {\n          const subProxy = new this.constructor(`${this.name}.${path}`)\n          // check object properties for other objects or arrays\n          value = Object.keys(value).reduce((acc, key) => {\n            acc[key] = this.recurse(`${path}.${key}`, value[key])\n            if (typeof acc[key] === 'object' && acc[key] !== null) { acc[key]._skruv_parent = subProxy }\n            return acc\n          }, {})\n          value = new Proxy(value, subProxy)\n          value._skruv_parent = this\n          this._resolve()\n        } else if (value.constructor === Array) {\n          const subProxy = new this.constructor(`${this.name}.${path}`)\n          // check arrays for objects or arrays\n          value = value.map((child, key) => {\n            const newValue = this.recurse(`${path}[${key}]`, child)\n            if (typeof newValue === 'object' && newValue !== null) { newValue._skruv_parent = subProxy }\n            return newValue\n          })\n          value = new Proxy(value, subProxy)\n          value._skruv_parent = this\n          this._resolve()\n        } else {\n          this._resolve()\n        }\n      } else {\n        this._resolve()\n      }\n      return value\n    }\n  }\n\n  // create root proxy\n  const rootProxy = new Proxy(stateObj.constructor === Array ? [] : {}, new Handler('root'))\n  Object.assign(rootProxy, stateObj)\n  return rootProxy\n}\n", "let hydrating = true\nconst generatorResults = new WeakMap()\nlet hydrationResolve = () => { }\nconst hydrationPromise = (new Promise(resolve => { hydrationResolve = () => resolve(true) }))\nconst waitingGens = new Set()\n\n/**\n * @param {AsyncGenerator<any>|AsyncIterator<any>|Promise<any>|(()=>any)} value\n * @param {string|number} key\n * @param {Array<any>|Object} parent\n * @param {{_r:{_r:() => boolean}}} cbparent\n * @param {Object|string|number|boolean|{a:{'data-skruv-finished':boolean}}} result\n * @returns {boolean}\n */\nconst process = (value, key, parent, cbparent, result) => {\n  if (hydrating && !(typeof result === 'object' && 'a' in result && result?.a?.['data-skruv-finished'] === false)) {\n    waitingGens.delete(value)\n    if (!waitingGens.size) {\n      // TODO: Check if needed\n      hydrating = false\n      setTimeout(() => hydrationResolve(), 0)\n    }\n  }\n  generatorResults.set(value, result)\n  // @ts-ignore: This complains, but we will always get either array and number key or object and string key\n  parent[key] = result\n  return cbparent._r._r()\n}\n\n/**\n * @param {AsyncGenerator<any>|AsyncIterator<any>|Promise<any>|(()=>any)|string|number|boolean} value\n * @param {string|number} key\n * @param {Array<any>|Object} parent\n * @param {{_r:{_r:() => boolean}}} cbparent\n * @returns {any?}\n */\nconst syncify = (value, key, parent, cbparent, root = true) => {\n  if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || value === null) {\n    return value\n  }\n  if (generatorResults.has(value)) {\n    return generatorResults.get(value)\n  }\n  if (\n    (typeof value === 'object' && Symbol.asyncIterator in value) ||\n    (typeof value === 'function' && value.constructor.name === 'AsyncGeneratorFunction')\n  ) {\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(value, null);\n    (async () => {\n      for await (const result of (typeof value === 'function' ? value() : value)) {\n        if (!process(\n          value,\n          key,\n          parent,\n          cbparent,\n          syncify(result, key, parent, cbparent, false)\n        )) {\n          break\n        }\n      }\n    })()\n    return null\n  }\n  if (\n    (typeof value === 'object' && 'then' in value && typeof value.then === 'function') ||\n    (typeof value === 'function' && value.constructor.name === 'AsyncFunction')\n  ) {\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(value, null);\n    (async () => {\n      process(\n        value,\n        key,\n        parent,\n        cbparent,\n        syncify(\n          await (typeof value === 'function' ? value() : value),\n          key,\n          parent,\n          cbparent,\n          false\n        )\n      )\n    })()\n    return null\n  }\n  if (typeof value === 'function') {\n    // check for eventlisteners or internal functions\n    // TODO: Have some sort of way to pass functions to web components\n    if (typeof key === 'string' && ((key[0] === 'o' && key[1] === 'n') || key[0] === '_')) {\n      return value\n    }\n    const newValue = syncify(value(), key, parent, cbparent, false)\n    generatorResults.set(value, newValue)\n    return newValue\n  }\n  if (typeof value === 'object') {\n    /** @type {{_r:{_r:() => boolean}}|Array<any>} */\n    let newVal = {\n      _r: {\n        _r: () => {\n          if ((hydrating && !waitingGens.size) || !hydrating) {\n            hydrating = false\n            setTimeout(() => hydrationResolve(), 0)\n          }\n          return true\n        }\n      }\n    }\n    let cb = newVal\n    if (Array.isArray(value)) {\n      newVal = []\n      cb = cbparent\n    }\n    if (key === 'a') {\n      newVal = {}\n      cb = cbparent\n    }\n    // Object with dummy default rerender callback\n    for (const key in value) {\n      // @ts-ignore: TODO: Have a stricter check than typeof value === 'object' above\n      const partialNewVal = syncify(value[key], key, newVal, cb, false)\n      if (partialNewVal !== null || value[key] === null) {\n        // @ts-ignore: This complains, but we will always get either array and number key or object and string key\n        newVal[key] = partialNewVal\n      }\n    }\n    // If we are at the root and did a pass with no async work the promise should resolve\n    if ((root && hydrating && !waitingGens.size) || !hydrating) {\n      hydrating = false\n      setTimeout(() => hydrationResolve(), 0)\n    }\n    return newVal\n  }\n  return value\n}\n\nexport { hydrationPromise, syncify }\n", "import { elementFactory, render } from '../../index.js'\nimport { css, cssTextGenerator } from '../../utils/css.js'\nimport { createState } from '../../utils/state.js'\nimport { hydrationPromise, syncify } from '../../utils/syncify.js'\n\nconst { html, head, title, meta, link, body, main, h1, form, label, input, button, ol, li, a, style, script } = elementFactory\n\nconst state = createState({\n  todos: ['Write todos']\n})\n\nconst styles = css`:scope{color:#f1f1f1;background:#0f0f0f}body{max-width:40ch;margin:0 auto}form{display:flex;align-items:end}label{flex:1}input{width:100%}a{color:#9b9b9b}`\n\nconst dom = syncify(\n  html({ lang: 'en-US', class: styles },\n    head(\n      title(state.todos.getGenerator(0)),\n      meta({ name: 'viewport', content: 'width=device-width, initial-scale=1' }),\n      style(cssTextGenerator),\n      link({ rel: 'icon', href: '/icon.svg', type: 'image/svg+xml', sizes: 'any' }),\n      meta({ name: 'description', content: 'Skruv todo-list' })\n    ),\n    body(\n      main(\n        h1(state.todos.getGenerator(0)),\n        form({\n          onsubmit: e => {\n            e.preventDefault()\n            state.todos.unshift(new FormData(e.target).get('todo'))\n            e.target.reset()\n          }\n        },\n        label(\n          'What do you need to do?',\n          input({\n            type: 'text',\n            name: 'todo'\n          })\n        ),\n        button('New!')\n        ),\n        async function * () {\n          for await (const currentState of state) {\n            yield ol(\n              currentState.todos.map((todo, i) => li(\n                `${todo} `,\n                a({\n                  href: '#',\n                  onclick: e => {\n                    e.preventDefault()\n                    currentState.todos.splice(i, 1)\n                  }\n                }, 'x')\n              ))\n            )\n          }\n        }\n      ),\n      !!globalThis.skruvSSRScript && script({ type: 'module' }, globalThis.skruvSSRScript)\n    )\n  )\n)\n\nexport const doRender = async () => {\n  await hydrationPromise\n  render(dom)\n  // Microsleep to allow for rendering to finish\n  await new Promise(resolve => setTimeout(resolve, 0))\n}\n\ndoRender()\n"],
  "mappings": "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",
  "names": ["s", "eventPrefix", "h", "t", "c", "_a", "_b", "_c", "keyed", "domCache", "render", "current", "_currentNode", "parentNode", "isSvg", "_d", "currentNode", "doc", "key", "evt", "children", "i", "keyedNode", "elementFactory", "_", "name", "resolveStyles", "promiseStyles", "resolve", "styleMap", "hash", "str", "i", "css", "strings", "keys", "_a", "stylesheet", "prev", "curr", "attrRe", "walkSelectorRe", "scopeRe", "consumeSelector", "raw", "prefix", "leftmost", "scope", "depth", "outer", "char", "match", "updateSelectorText", "selectorText", "found", "consumed", "upgradeRule", "rule", "l", "j", "retval", "sheet", "styleDoc", "styleElem", "e", "upgradedStyles", "cssTextGenerator", "resolveTimer", "cb", "createState", "stateObj", "Handler", "name", "resolve", "target", "key", "value", "proxy", "booted", "acc", "curr", "_a", "res", "path", "item", "subProxy", "child", "newValue", "rootProxy", "hydrating", "generatorResults", "hydrationResolve", "hydrationPromise", "resolve", "waitingGens", "process", "value", "key", "parent", "cbparent", "result", "_a", "syncify", "root", "newValue", "newVal", "cb", "partialNewVal", "html", "head", "title", "meta", "link", "body", "main", "h1", "form", "label", "input", "button", "ol", "li", "a", "style", "script", "elementFactory", "state", "createState", "styles", "css", "dom", "syncify", "cssTextGenerator", "currentState", "todo", "i", "e", "doRender", "hydrationPromise", "render", "resolve"]
}
