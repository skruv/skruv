{
  "version": 3,
  "sources": ["index.js"],
  "sourcesContent": ["/**\n * @typedef {Record<string,(string|boolean|Function|number)> & {'data-skruv-key'?: object, 'data-skruv-finished'?: boolean, 'data-skruv-wait-for-not-empty'?: boolean, 'data-skruv-after-create'?:(e: Node) => void, 'data-skruv-after-remove'?:(e: Node) => void }} VnodeAttributes\n * @typedef {Vnode|VnodeAttributes} SkruvChildNode\n * @typedef {SkruvChildNode[]} SkruvChildNodes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {string} t\n * @prop {SkruvChildNodes} c\n * @prop {() => boolean} [r]\n */\nconst htmlNS = 'http://www.w3.org/1999/xhtml'\nconst svgNS = 'http://www.w3.org/2000/svg'\nconst mathmlNS = 'http://www.w3.org/1998/Math/MathML'\n// This namespace is not generally understood by browsers, so only used in minidom\n// const atomNS = 'http://www.w3.org/2005/Atom'\n/** @type {WeakMap<Node|object, Node|Object>} */\nconst keyed = new WeakMap()\n/** @type {WeakMap<Node, Object>} */\nconst oldKeys = new WeakMap()\n/** @type {WeakMap<Node, Record<string, function|string|boolean|object>>} */\nconst attributesMap = new WeakMap()\n/** @type {Record<string, Node>} */\nconst domCache = {}\n/**\n * @param {import(\"./utils/stateType\").Vnode} current\n * @param {Element} currentNode\n * @param {ParentNode?} parentNode\n * @param {string} ns\n */\nexport const render = (\n  current,\n  currentNode = globalThis.document.documentElement,\n  parentNode = currentNode.parentNode,\n  ns = htmlNS,\n  forceFull = false\n) => {\n  if (!parentNode) {\n    throw new Error('No parent to render to')\n  }\n  if (typeof current === 'boolean') {\n    if (currentNode) { parentNode.removeChild(currentNode) }\n    return\n  }\n  const txtNode = (typeof current === 'string' || typeof current === 'number')\n  if (\n    forceFull ||\n    !currentNode ||\n    (txtNode && currentNode.nodeName !== '#text') ||\n    (!txtNode && currentNode.nodeName.toLowerCase() !== current.t.toLowerCase())\n  ) {\n    const _currentNode = currentNode\n    if (txtNode) {\n      // @ts-ignore: When this is a textnode we will only use it for text, so this should be fine\n      currentNode = document.createTextNode('' + current)\n    } else {\n      if (current.t === 'svg') { ns = svgNS }\n      if (current.t === 'math') { ns = mathmlNS }\n      // @ts-ignore: All the nodes are actually elements, since the domCache only contains elements\n      currentNode = (domCache[current.t] || (domCache[current.t] = document.createElementNS(ns, current.t))).cloneNode(false)\n    }\n    if (_currentNode) {\n      parentNode.replaceChild(currentNode, _currentNode)\n    } else {\n      parentNode.appendChild(currentNode)\n    }\n    if (txtNode) { return }\n  }\n  if (txtNode) {\n    // We do a loose comparison to allow for numbers\n    // eslint-disable-next-line eqeqeq\n    if (currentNode.textContent != current) { currentNode.textContent = '' + current }\n    return\n  }\n  if (current.r) {\n    current.r = () => {\n      if (!currentNode || !parentNode.contains(currentNode)) { return false }\n      render(current, currentNode, parentNode, ns)\n      return true\n    }\n  }\n  // This needs to come after the .r callback is registered since it should apply to child nodes, not the current node.\n  // TODO: How to handle things that are named the same in multiple namespaces (like title in both HTML and SVG)\n  if (current.t === 'foreignObject') { ns = htmlNS }\n  /** @type {import(\"./utils/stateType\").Vnode[]} */\n  // @ts-ignore\n  let children = current.c.flat(Infinity)\n  /** @type {import(\"./utils/stateType\").attributes} */\n  // @ts-ignore\n  let attributes = {}\n  if (children[0]?.constructor === Object && !children[0]?.isSkruvDom) {\n    // @ts-ignore\n    attributes = children[0]\n    children = children.slice(1)\n    let oldAttributes = attributesMap.get(currentNode)\n    if (!oldAttributes) {\n      oldAttributes = {}\n      attributesMap.set(currentNode, oldAttributes)\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (('' + oldAttributes[key]) === ('' + value)) { continue }\n      if (key === 'data-skruv-key') { continue }\n      if (key === 'data-skruv-after-create') {\n        // Run after we have processed all the attributes and children\n        setTimeout(() => value(currentNode), 0)\n        oldAttributes[key] = value\n        continue\n      }\n      if (key[0] === 'o' && key[1] === 'n') {\n        const evt = key.slice(2)\n        if (!oldAttributes[key]) {\n          if (oldAttributes[key]) { currentNode.removeEventListener(evt, value) }\n          currentNode.addEventListener(evt, value)\n        } else if (!value) {\n          currentNode.removeEventListener(evt, value)\n        }\n        oldAttributes[key] = value\n        continue\n      }\n      if (\n        (key === 'checked' || key === 'selected' || key === 'value') ||\n        currentNode.nodeName.includes('-') // Support complex data passing for custom elements\n      ) {\n        // @ts-ignore We have to index the element for custom elements or setting checked/selected/value\n        currentNode[key] = value\n      }\n      if (value) {\n        currentNode.setAttribute(key, '' + value)\n      } else {\n        currentNode.removeAttribute(key)\n      }\n      oldAttributes[key] = value\n      continue\n    }\n  }\n  if (!children.length && currentNode.childNodes.length) {\n    if (attributes['data-skruv-wait-for-not-empty']) {\n      return\n    }\n    currentNode.replaceChildren()\n    return\n  }\n  if (currentNode.childNodes.length > children.length) {\n    for (let i = (currentNode.childNodes.length - 1); i >= children.length; i--) {\n      currentNode.removeChild(currentNode.childNodes[i])\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    let forceFull = false\n    /** @type {Element} */\n    let keyedNode\n    if (children[i]?.c) {\n      keyedNode = keyed.get(children[i].c[0]?.['data-skruv-key'])\n      if (keyedNode) {\n        if (keyedNode !== currentNode.childNodes[i]) {\n          if (keyedNode === currentNode.childNodes[i + 1]) {\n            currentNode.removeChild(currentNode.childNodes[i])\n          } else if (currentNode.childNodes[i] && keyed.get(children[i + 1]?.c?.[0]?.['data-skruv-key']) === currentNode.childNodes[i]) {\n            currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n          } else if (currentNode.childNodes[i]) {\n            currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n          } else {\n            currentNode.appendChild(keyedNode)\n          }\n        }\n        forceFull = children[i].c[0]['data-skruv-key'] !== oldKeys.get(currentNode.childNodes[i])\n        if (!forceFull) {\n          const lastKeyCopy = keyed.get(currentNode.childNodes[i])\n          if (lastKeyCopy) {\n            let noChange = true\n            for (const k in children[i].c[0]['data-skruv-key']) {\n              if (children[i].c[0]['data-skruv-key'][k] !== lastKeyCopy[k]) {\n                noChange = false\n              }\n            }\n            if (noChange) { continue }\n          }\n        }\n      } else {\n        forceFull = keyed.has(currentNode.childNodes[i])\n      }\n    }\n    // @ts-ignore: This will be fine since if the node is of the wrong type a new one is created\n    render(children[i], currentNode.childNodes[i] || false, currentNode, ns, forceFull)\n  }\n  if (attributes['data-skruv-key']) {\n    keyed.set(attributes['data-skruv-key'], currentNode)\n    oldKeys.set(currentNode, attributes['data-skruv-key'])\n    keyed.set(currentNode, { ...attributes['data-skruv-key'] })\n  }\n}\n\n/** @type {import(\"./utils/stateType\").ElementMap} */\n// @ts-ignore\nexport const elementFactory = new Proxy({}, { get: (_, t) => (...c) => ({ isSkruvDom: true, t, c }) })\n"],
  "mappings": "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",
  "names": ["htmlNS", "svgNS", "mathmlNS", "keyed", "oldKeys", "attributesMap", "domCache", "render", "current", "currentNode", "parentNode", "ns", "forceFull", "_a", "_b", "_c", "_d", "_e", "_f", "_g", "txtNode", "_currentNode", "children", "attributes", "oldAttributes", "key", "value", "evt", "i", "keyedNode", "lastKeyCopy", "noChange", "k", "elementFactory", "_", "t", "c"]
}
