{
  "version": 3,
  "sources": ["../../index.js", "../../utils/jsx-runtime.js", "index.jsx"],
  "sourcesContent": ["const s = Symbol.for('skruvDom')\nconst eventPrefix = 'data-event-'\n/**\n * @typedef {Vnode|Vnode[]|String|Boolean|Number} SkruvChildNode\n * @typedef {SkruvChildNode[]} SkruvChildNodes\n * @typedef {Record<string,(string|boolean|Function|number|Object)>} VnodeAtrributes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} c\n * @prop {Record<string,(string|boolean|Function|number|Object)> & {_r:{_r:() => boolean}?}} a\n * @prop {{_r:() => boolean}} [_r]\n */\n/**\n * @param {string} t\n * @param  {(Record<string, any>|Vnode)[]} c\n * @returns {Vnode}\n */\n// @ts-ignore: TODO: The check for non-attribute objects does not satisfy TS\nexport const h = (t, ...c) => ({\n  s,\n  t: t.toUpperCase(),\n  ...(\n    // @ts-ignore: its exactly because we don't know if its there that we check it\n    !(c[0]?.[Symbol.asyncIterator]) &&\n        c[0]?.constructor === Object &&\n      c[0]?.s !== s\n      ? {\n        a: c[0],\n        c: c.slice(1)\n      }\n      : {\n        a: {},\n        c: c\n      }\n  )\n})\n\n/** @type {WeakMap<Vnode, Node>} */\nconst keyed = new WeakMap()\n/** @type {Record<string, Node>} */\nconst domCache = {}\n/**\n * @param {Vnode} current\n * @param {Node} _currentNode\n * @param {ParentNode?} parentNode\n * @param {*} isSvg\n * @returns {boolean}\n */\nexport const render = (\n  current,\n  _currentNode = globalThis.document.documentElement,\n  parentNode = _currentNode.parentNode,\n  isSvg = false\n) => {\n  let currentNode = _currentNode\n  if (!parentNode || !parentNode.ownerDocument || (currentNode && !parentNode.contains(currentNode))) { return false }\n  if (typeof current === 'boolean' || current === null || current === undefined) {\n    if (currentNode) { parentNode.removeChild(currentNode) }\n    return true\n  }\n  if (\n    ((typeof current === 'string' || typeof current === 'number') && currentNode?.nodeName !== '#text') ||\n    (current?.t && currentNode?.nodeName !== current?.t) ||\n    // @ts-ignore: TODO: Handle key storage better\n    (currentNode?._skruvKey !== current?.a?._key)\n  ) {\n    if (typeof current === 'string' || typeof current === 'number') {\n      currentNode = (domCache.text || (domCache.text = parentNode.ownerDocument.createTextNode(''))).cloneNode()\n    } else if (isSvg || current.t === 'svg') {\n      currentNode = (domCache[current.t] || (domCache[current.t] = parentNode.ownerDocument.createElementNS('http://www.w3.org/2000/svg', current.t))).cloneNode()\n    } else {\n      currentNode = (domCache[current.t] || (domCache[current.t] = parentNode.ownerDocument.createElement(current.t))).cloneNode()\n    }\n    if (_currentNode) {\n      parentNode.replaceChild(currentNode, _currentNode)\n    } else {\n      parentNode.appendChild(currentNode)\n    }\n    // @ts-ignore: see above\n    currentNode._skruvKey = current?.a?._key\n    // @ts-ignore: oncreate should always be callable. TODO: add strict typing\n    if (current?.a?.oncreate) { current.a.oncreate(currentNode) }\n  }\n  if ((typeof current === 'string' || typeof current === 'number')) {\n    // @ts-ignore: We already checked this above. It's not 'never'\n    if (('' + currentNode.data) !== ('' + current)) { currentNode.data = current }\n    return true\n  }\n  if (current._r) { current._r._r = () => render(current, currentNode, parentNode, isSvg) }\n  for (const key in current.a) {\n    if (key[0] === 'o' && key[1] === 'n') {\n      const evt = key.slice(2)\n      // @ts-ignore: TODO: this is a hacky way to store what the last eventlistener was\n      if (!currentNode[eventPrefix + key] || ('' + currentNode[eventPrefix + key]) !== ('' + current.a[key])) {\n        // @ts-ignore: See above\n        if (currentNode[eventPrefix + key]) { currentNode.removeEventListener(evt, currentNode[eventPrefix + key]) }\n        // @ts-ignore: See above\n        currentNode.addEventListener(evt, current.a[key])\n        // @ts-ignore: See above\n        currentNode[eventPrefix + key] = current.a[key]\n      } else if (!current.a[key]) {\n        // @ts-ignore: data-event-* is the old function\n        currentNode.removeEventListener(evt, currentNode[eventPrefix + key])\n      }\n    // @ts-ignore: If this was a text or comment element we would have returned above\n    } else if (current.a[key] !== currentNode.getAttribute(key)) {\n      if (\n        (\n          typeof current.a[key] === 'boolean' &&\n          (\n            (current.t === 'INPUT' && key === 'checked') ||\n            (current.t === 'OPTION' && key === 'selected')\n          )\n        ) || typeof current.a[key] === 'object' // Support complex data passing for custom elements\n      ) {\n        // @ts-ignore TS does not think HTML properties are accessible directly?\n        currentNode[key] = current.a[key]\n      }\n      if (current.a[key]) {\n        // @ts-ignore: If this was a text or comment element we would have returned above\n        currentNode.setAttribute(key, '' + current.a[key])\n      } else {\n        // @ts-ignore: If this was a text or comment element we would have returned above\n        currentNode.removeAttribute(key)\n      }\n    }\n  }\n  const children = current.c.flat(Infinity)\n  if (!children.length && currentNode.childNodes.length) {\n    if (current.a['data-skruv-wait-for-not-empty']) {\n      return true\n    }\n    // @ts-ignore: If this was a text or comment element we would have returned above\n    currentNode.replaceChildren()\n    return true\n  }\n  if (currentNode.childNodes.length > children.length) {\n    for (let i = children.length; i < currentNode.childNodes.length; i++) {\n      currentNode.removeChild(currentNode.childNodes[i])\n    }\n  }\n  for (let i = 0; i < children.length; i++) {\n    // @ts-ignore: TODO: the flattening seems to confuse TS\n    if (keyed.has(children[i])) {\n      // @ts-ignore: See above\n      const keyedNode = keyed.get(children[i])\n      if (keyedNode !== currentNode.childNodes[i]) {\n        if (keyedNode === currentNode.childNodes[i + 1]) {\n          currentNode.removeChild(currentNode.childNodes[i])\n        // @ts-ignore: See above\n        } else if (keyed.has(children[i + 1]) && keyed.get(children[i + 1]) === currentNode.childNodes[i]) {\n          // @ts-ignore\n          currentNode.insertBefore(keyedNode, currentNode.childNodes[i])\n        } else if (currentNode.childNodes[i]) {\n          // @ts-ignore\n          currentNode.replaceChild(keyedNode, currentNode.childNodes[i])\n        } else {\n          // @ts-ignore\n          currentNode.appendChild(keyedNode)\n        }\n        // @ts-ignore: See above\n        keyed.set(children[i], currentNode.childNodes[i])\n      }\n      continue\n    }\n    // @ts-ignore: See above\n    render(children[i], currentNode.childNodes[i] || false, currentNode, isSvg)\n  }\n  keyed.set(current, currentNode)\n  return true\n}\n\nexport const elementFactory = new Proxy({}, {\n  /** @type {(_: any, name: string) => (arg0: (Record<string, any>|Vnode)[]) => Vnode} */\n  get: (_, name) => (...c) => h(name, ...c)\n})\n", "/**\n * @typedef {Vnode|Vnode[]|String|Boolean|Number} SkruvChildNode\n * @typedef {SkruvChildNode[]} SkruvChildNodes\n * @typedef {Record<string,(string|boolean|Function|number|Object)>} VnodeAtrributes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} c\n * @prop {Record<string,(string|boolean|Function|number|Object)> & {_r:{_r:() => boolean}?}} a\n * @prop {{_r:() => boolean}} [_r]\n */\nimport { h } from '../index.js'\n\n/**\n * @typedef {Object} JSXAdditionalProperties\n * @property {[Vnode]} [children]\n *\n * @typedef {VnodeAtrributes & JSXAdditionalProperties} JSXAttributes\n */\n\n/**\n * @param {String} str\n * @returns {String}\n */\nconst kebabize = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase())\n\nexport const Fragment = '#fragment'\n\n/**\n * @param {String} nodeName\n * @param {JSXAttributes} [attributes={}]\n * @returns {Vnode | [Vnode?]}\n */\nexport const jsx = (nodeName, attributes = {}) => jsxs(nodeName, attributes)\n\n/**\n * @param {String} nodeName\n * @param {JSXAttributes} [attributes={}]\n * @returns {Vnode | [Vnode?]}\n */\nexport const jsxs = (nodeName, attributes = {}) => {\n  if (nodeName === Fragment && attributes.children) { return attributes.children }\n  if (nodeName === Fragment) { return [] }\n  const { children, ...attrs } = attributes\n  Object.keys(attrs).filter(e => e !== kebabize(e))\n    .forEach(e => {\n      attrs[kebabize(e)] = attrs[e]\n      delete attrs[e]\n    })\n  if (attrs['class-name']) {\n    attrs.class = attrs['class-name']\n    delete attrs['class-name']\n  }\n  if (attrs['html-for']) {\n    attrs.for = attrs['html-for']\n    delete attrs['html-for']\n  }\n  if (children) { return h(nodeName, attrs || {}, children) }\n  return h(nodeName, attrs || {})\n}\n", "import { render } from 'skruv'\n\nconst styles = /* css */`:root{color:#fff;background:#0f0f0f}`\n\nrender(\n  <html lang=\"en-US\">\n    {/* Fragments work too, but are usually not needed. */}\n    <>\n      <head>\n        <title>jsx</title>\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <style>{styles}</style>\n      </head>\n    </>\n    <body>\n      <div>\n        <p>Hello world</p>\n      </div>\n    </body>\n  </html>\n)\n"],
  "mappings": "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",
  "names": ["s", "eventPrefix", "h", "t", "c", "_a", "_b", "_c", "keyed", "domCache", "render", "current", "_currentNode", "parentNode", "isSvg", "currentNode", "key", "evt", "children", "i", "keyedNode", "elementFactory", "_", "name", "kebabize", "str", "$", "ofs", "Fragment", "jsx", "nodeName", "attributes", "jsxs", "children", "attrs", "h", "styles", "render", "jsxs", "jsx", "Fragment"]
}
