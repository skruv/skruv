{
  "version": 3,
  "sources": ["../../index.js", "../../utils/css.js", "../../utils/state.js", "../../utils/jsx-runtime.js", "index.jsx"],
  "sourcesContent": ["/* global HTMLInputElement HTMLOptionElement Text Comment HTMLElement SVGElement Document Window */\n\n/**\n * @typedef {Vnode|Function|String|Number|Boolean|SkruvAsyncGenerator|SkruvAsyncIterable|SkruvPromise|SkruvAsyncFunction} SkruvValue\n * @typedef {(AsyncGenerator<Function|String|Boolean|Number>|AsyncIterable<Function|String|Boolean|Number>)} SkruvAttributesIterable\n * @typedef {(Promise<Function|String|Boolean|Number>|function(): Promise<Function|String|Boolean|Number>)} SkruvAttributesPromiseOrAsyncFunction\n * @typedef {Partial<GlobalEventHandlers> & Record<string,(string|boolean|Function|number|Object)>} PreparedVnodeAtrributes\n * @typedef {PreparedVnodeAtrributes & Record<string,(string|boolean|Function|number|Object|SkruvAttributesPromiseOrAsyncFunction|SkruvAttributesIterable)>} VnodeAtrributes\n * @typedef {AsyncGenerator<SkruvValue>} SkruvAsyncGenerator\n * @typedef {AsyncIterable<SkruvValue>} SkruvAsyncIterable\n * @typedef {Promise<SkruvValue>} SkruvPromise\n * @typedef {function(): Promise<SkruvValue>} SkruvAsyncFunction\n * @typedef {Vnode|Vnode[]|SkruvValue} SkruvChildNode\n * @typedef {Array<SkruvChildNode>} SkruvChildNodes\n */\n/**\n * @typedef {object} Vnode\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} _c\n * @prop {VnodeAtrributes} _a\n * @prop {{r:() => boolean}} r\n */\n/**\n * @typedef {object} PreparedVnode\n * @prop {Symbol} p\n * @prop {Symbol} s\n * @prop {String} t\n * @prop {SkruvChildNodes} _c\n * @prop {VnodeAtrributes} _a\n * @prop {{r:() => boolean}} r\n * @prop {Array<PreparedVnode>} c\n * @prop {PreparedVnodeAtrributes} a\n */\nconst s = Symbol.for('skruvDom')\nconst p = Symbol.for('skruvDomPrepared')\n/** @type {WeakMap<SkruvAsyncGenerator|SkruvAsyncIterable|SkruvPromise|SkruvAsyncFunction|Function|Vnode, SkruvValue?>} */\nconst generatorResults = new WeakMap()\n\n/** @type {WeakMap<Node, Record<string,EventListener?>>} */\nconst skruvListeners = new WeakMap()\n\n/** @type {WeakMap<Object, Node>} */\nconst keyedNodes = new WeakMap()\n\nlet hydrationResolve = () => {}\n/** @type {Promise<void>} */\nconst hydrationPromise = (new Promise(resolve => { hydrationResolve = () => resolve() }))\n\n/** @type {Set<SkruvAsyncGenerator|SkruvAsyncIterable|SkruvPromise|SkruvAsyncFunction|Function|Vnode?>} */\nconst waitingGens = new Set()\n\n// @ts-ignore This is a global set by SSR/Tests\nlet hydrating = globalThis?.SkruvWaitForAsync || !!document.querySelector('data-skruv-ssr-rendered')\n\n/** @type {Vnode} */\nexport const Vnode = { s, t: '', _c: [], _a: {}, r: { r: () => false } }\n\n/** @type {VnodeAtrributes} */\nexport const VnodeAtrributes = {}\n\n/**\n * @param {string} t\n * @param  {Array<SkruvChildNode|VnodeAtrributes>} c\n * @returns {Vnode}\n */\n// @ts-ignore TODO: TS seems to be confused about the spreading of attributes and children. Try separating them\nexport const h = (t, ...c) => ({\n  s,\n  t,\n  ...(\n    typeof c[0] === 'object' &&\n    !Array.isArray(c[0]) &&\n    !(c[0] instanceof Function) && !(c[0] instanceof Function && c[0]?.prototype?.toString?.() === '[object AsyncGenerator]') &&\n    // @ts-ignore How to check for booted generators?\n    !(c[0]?.[Symbol.asyncIterator]) &&\n    // @ts-ignore TODO: check why this still thinks a function can fall though\n    c[0]?.s !== s\n      ? {\n        _a: c[0],\n        _c: c.slice(1)\n      }\n      : {\n        _a: {},\n        _c: c\n      }),\n  r: {\n    r: () => {\n      if (hydrating && !waitingGens.size) {\n        hydrating = false\n        hydrationResolve()\n      }\n      return true\n    }\n  }\n})\n\n// This functions takes in a potentially async value and makes it sync\n/**\n * @param {SkruvValue} value\n * @param  {PreparedVnode} parent\n * @param  {boolean} toVnodes\n * @returns {SkruvValue}\n */\nconst syncify = (value, parent, toVnodes) => {\n  /**\n   *\n   * @param {Function | SkruvAsyncIterable | SkruvPromise | Vnode} value\n   * @param {string | number | boolean | Function | Vnode | SkruvAsyncIterable | SkruvPromise | null} result\n   * @returns\n   */\n  const process = (value, result) => {\n    // @ts-ignore optional chaining\n    if (hydrating && result?._a?.['data-skruv-finished'] !== false) {\n      waitingGens.delete(value)\n      // Make sure any async calls that returned other async nodes get added to the hydration queue\n      if (result) {\n        // @ts-ignore vdom typeguard\n        if (result?.s === s) { flatten(result) } else { syncify(result, parent, toVnodes) }\n      }\n    }\n    generatorResults.set(value, result)\n    return parent.r.r()\n  }\n  // @ts-ignore maybe stricten up checks here\n  if (generatorResults.has(value)) { return generatorResults.get(value) }\n  // @ts-ignore TODO: Check what is the right way to detect started asynciterators\n  if (typeof value === 'object' && value?.[Symbol.asyncIterator]) {\n    const val = (/** @type {SkruvAsyncIterable} */ (value))\n    if (hydrating) { waitingGens.add(val) }\n    generatorResults.set(val, null);\n    (async () => { for await (const result of val) { if (!process(value, result)) { break } } })()\n    return false\n  } else if (value instanceof Function && value?.prototype?.toString?.() === '[object AsyncGenerator]') {\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(value, null);\n    (async () => { for await (const result of value()) { if (!process(value, result)) { break } } })()\n    return false\n    // @ts-ignore TODO: .then might not exist, but thats why I'm checking it!\n  } else if (typeof value === 'object' && value !== null && value?.then instanceof Function) {\n    const val = (/** @type {SkruvPromise} */ (value))\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(val, null);\n    (async () => { process(val, await val) })()\n    return false\n  } else if (typeof value === 'function' && value.constructor.name === 'AsyncFunction') {\n    if (hydrating) { waitingGens.add(value) }\n    generatorResults.set(value, null);\n    (async () => { process(value, await value()) })()\n    return false\n  } else if (typeof value === 'function') {\n    if (toVnodes) {\n      return value()\n    }\n    return value\n  } else if (typeof value === 'string' || typeof value === 'number') {\n    if (toVnodes) {\n      return h('#text', { data: value.toString() })\n    }\n    return value.toString()\n  } else if (typeof value === 'boolean') {\n    return value\n  }\n  throw new Error('Unkown type in syncify: ' + JSON.stringify(value))\n}\n\n/**\n *\n * @param {SkruvChildNodes} c\n * @param {Vnode} skruvDom\n * @returns {PreparedVnode[]}\n */\nconst recurseVnodes = (c, skruvDom) => {\n  const newVnodes = c.flat(Infinity)\n    // @ts-ignore TS does not understand that .s is a typeguard for vnodes\n    .map(value => value?.s === s ? flatten(value) : syncify(value, skruvDom, true))\n    .flat(Infinity)\n    .filter(value => value !== null && typeof value !== 'boolean' && typeof value !== 'undefined')\n  // @ts-ignore Optional chaining\n  if (newVnodes.find(value => value?.p !== p) !== undefined) {\n    return recurseVnodes(newVnodes, skruvDom)\n  }\n  // @ts-ignore We already guard against this with the .p check above\n  return newVnodes\n}\n\n// This needs all sorts of cleanup\n// TODO: Instead of modifying the object have the r function be an object ({r:()=>}) so you can replace the inner function without having to modify the original\n/**\n * @param {Vnode} skruvDom\n * @returns {PreparedVnode}\n */\nconst flatten = skruvDom => {\n  const a = Object.fromEntries(\n    Object.entries(skruvDom._a)\n      .filter(entry => entry[1] !== null && typeof entry[1] !== 'undefined')\n      // @ts-ignore We already check null above\n      .map(([key, value]) => key === 'data-skruv-key' ? [key, value] : [key, syncify(value, skruvDom, false)])\n      .filter(entry => entry[1] !== null && typeof entry[1] !== 'undefined')\n  )\n  return {\n    p,\n    ...skruvDom,\n    a,\n    c: recurseVnodes(skruvDom._c, skruvDom)\n  }\n}\n\n/**\n * @param {PreparedVnode} current\n * @param {Element} currentNode\n * @param {ParentNode?} parentNode\n * @param {boolean} isSvg\n */\nconst renderRecursive = (current, currentNode, parentNode, isSvg) => {\n  if (current.p !== p) {\n    throw new Error('unkown type in render: ' + JSON.stringify(current))\n  }\n  for (const c of current.c) {\n    if (c.p !== p) {\n      throw new Error('unkown type in render: ' + JSON.stringify(c))\n    }\n  }\n  if (!parentNode || (currentNode && !parentNode.contains(currentNode))) { return false }\n  const ownerDocument = currentNode.ownerDocument\n  const documentElement = ownerDocument.documentElement\n\n  for (const key of currentNode.getAttributeNames().filter(k => !Object.keys(current.a).includes(k))) {\n    currentNode.removeAttribute(key)\n  }\n\n  for (const [key, value] of Object.entries(current.a)) {\n    if (key === 'data-skruv-key') { continue }\n    /** @type {EventListenerOrEventListenerObject} */\n    if (key.slice(0, 2) === 'on') {\n      let listeners = skruvListeners.get(currentNode)\n      const curr = listeners?.[key]\n      const event = key.slice(2)\n      if (!listeners) {\n        listeners = {}\n        skruvListeners.set(currentNode, listeners)\n      }\n      if (value instanceof Function) {\n        if (curr && curr.toString() !== value.toString()) {\n          currentNode.removeEventListener(event, curr)\n          listeners[key] = null\n        }\n        if (!curr) {\n          // @ts-ignore EventListener and Function are incompatible according to TS\n          listeners[key] = value\n          // @ts-ignore EventListener and Function are incompatible according to TS\n          currentNode.addEventListener(event, value)\n        }\n        continue\n      }\n      if (curr && !value) {\n        currentNode.removeEventListener(event, curr)\n        listeners[key] = null\n      }\n    }\n    if (value === null || value === false) {\n      if (currentNode.getAttribute(key)) {\n        currentNode.removeAttribute(key)\n      }\n      continue\n    }\n    currentNode.setAttribute(key, value.toString())\n    if (key === 'value' && (typeof value === 'number' || typeof value === 'string') && currentNode instanceof HTMLInputElement) {\n      currentNode[key] = value.toString()\n    }\n    if (\n      (\n        typeof value === 'boolean' &&\n        (\n          (currentNode instanceof HTMLInputElement && key === 'checked') ||\n          (currentNode instanceof HTMLOptionElement && key === 'selected')\n        )\n      ) || typeof value === 'object' // Support complex data passing for custom elements\n    ) {\n      // @ts-ignore TS does not think HTML properties are accessible directly?\n      currentNode[key] = value\n    }\n  }\n\n  current.r.r = () => renderRecursive(flatten(current), currentNode, parentNode, isSvg)\n\n  if (current.a['data-skruv-opaque']) {\n    return true\n  }\n\n  // Reuse of old nodes and handle keying\n  const prev = Array.from(currentNode.childNodes)\n  const curr = current.c\n  /** @type {Array<Node?>} */\n  const newOrder = []\n  /**\n   * @param {ChildNode} p\n   * @param {Vnode} c\n   * @returns {boolean}\n   */\n  const comp = (p, c) => p.nodeName.toLowerCase() === c.t && !newOrder.includes(p)\n  for (let ci = 0; ci < curr.length; ci++) {\n    const c = curr[ci]\n    const inPrev = c.a['data-skruv-key'] ? keyedNodes.get(c.a['data-skruv-key']) : prev.find(p => comp(p, c))\n    if (inPrev) {\n      newOrder[ci] = inPrev\n    } else {\n      newOrder[ci] = null\n    }\n  }\n  const toRemove = prev.filter(p => !newOrder.includes(p))\n\n  if (current.c.length || !current.a['data-skruv-wait-for-not-empty']) {\n    for (const elem of toRemove.filter(e => !!e)) {\n      currentNode.removeChild(elem)\n      // We have to do a microsleep before check since keyed nodes could have been moved to another location\n      setTimeout(() => {\n        if (!documentElement?.contains(elem) && skruvListeners.get(elem)?.onremove) { elem.dispatchEvent(new CustomEvent('remove')) }\n      }, 1)\n    }\n  }\n\n  for (let i = 0; i < newOrder.length; i++) {\n    const child = current.c[i]\n    let created = false\n    if (!newOrder[i]) {\n      let newChild\n      if (current.t === '#comment') {\n        newChild = ownerDocument.createComment('')\n      } else if (child.t === '#text') {\n        newChild = ownerDocument.createTextNode('')\n      } else if (child.p === p && (isSvg || child.t === 'svg')) {\n        newChild = ownerDocument.createElementNS('http://www.w3.org/2000/svg', child.t)\n      } else {\n        newChild = ownerDocument.createElement(child.t)\n      }\n      created = true\n      if (currentNode.childNodes[i]) {\n        currentNode.replaceChild(newChild, currentNode.childNodes[i])\n      } else if (i === 0) {\n        currentNode.prepend(newChild)\n      } else {\n        currentNode.childNodes[i - 1].after(newChild)\n      }\n    } else if (newOrder[i] !== currentNode.childNodes[i]) {\n      // Make ts happy\n      const nodeToMove = newOrder[i]\n      if (nodeToMove) {\n        if (i === 0) {\n          currentNode.prepend(nodeToMove)\n        } else {\n          currentNode.childNodes[i - 1].after(nodeToMove)\n        }\n      }\n    }\n    const childNode = currentNode.childNodes[i]\n    if ((childNode instanceof Text || childNode instanceof Comment)) {\n      if (childNode.data !== child.a.data) { childNode.data = child.a.data.toString() }\n      // Comment and text nodes have no attributes or children so bail here\n      continue\n    }\n    if (!(childNode instanceof HTMLElement || childNode instanceof SVGElement)) {\n      throw new Error('Child node of unknown type: ' + JSON.stringify({ childNode, child }))\n    }\n    if (child.a['data-skruv-key'] && !keyedNodes.has(child.a['data-skruv-key'])) { keyedNodes.set(child.a['data-skruv-key'], childNode) }\n    renderRecursive(child, childNode, currentNode, isSvg || current.t === 'svg')\n    if (created && skruvListeners.get(childNode)?.oncreate) { childNode.dispatchEvent(new CustomEvent('create')) }\n  }\n  return true\n}\n\n/**\n * @param {Vnode} current\n * @param {Element} [currentNode]\n * @param {ParentNode?} parentNode\n * @param {boolean} [isSvg]\n */\nexport const render = async (\n  current,\n  currentNode = document.documentElement,\n  parentNode = currentNode?.parentNode,\n  isSvg = false\n) => {\n  if (!parentNode) {\n    // TODO: create error classes for skruv, inherit from one single error class\n    throw new Error('Skruv: No parent to render to')\n  }\n  if (!(parentNode instanceof HTMLElement || parentNode instanceof SVGElement || parentNode instanceof Document || parentNode instanceof Window)) {\n    // TODO: create error classes for skruv, inherit from one single error class\n    throw new Error('Skruv: Parent of wrong type')\n  }\n  if (hydrating) {\n    // If we are hydrating we first do a pass to find all async nodes, resolve those and then do a full render\n    flatten(current).r.r()\n    await hydrationPromise\n  }\n  renderRecursive(flatten(current), currentNode, parentNode, isSvg)\n}\n\n/** @type {Record<string, ((...c: Array<SkruvChildNode|VnodeAtrributes>) => Vnode)>} */\nconst proxyBase = {}\nexport const htmlFactory = new Proxy(\n  proxyBase,\n  { get: (_target, /** @type {string} */name) => /** @param {Array<SkruvChildNode|VnodeAtrributes>} c */(...c) => h(name, ...c) }\n)\n", "/* global CSSMediaRule CSSStyleRule CSSOM */\n\n// TODO: package\n/** @type {function} */\nlet resolveStyles = () => {}\nlet promiseStyles = new Promise(resolve => { resolveStyles = resolve })\nconst styleMap = new Map()\n\n// // Example of using webcrypto for hashing. Only works if loaded over https, so not used. Also requires async\n// const encoder = new TextEncoder()\n// /**\n//  * @param {string} str\n//  * @returns {Promise<string>}\n//  */\n// const hash = async str => [...new Uint8Array(await crypto.subtle.digest('SHA-1', encoder.encode(str)))].map(x => x.toString(16).padStart(2, '0')).join('')\n\n/**\n * @param {string} str\n * @returns {string}\n */\nconst hash = str => {\n  let hash = 0\n  if (str.length === 0) { return hash.toString() }\n  for (let i = 0; i < str.length; i++) {\n    hash = ((hash << 5) - hash) + str.charCodeAt(i)\n    hash |= 0 // Convert to 32bit integer\n  }\n  return hash.toString()\n}\n\n/**\n * Scoped CSS helper\n * @param {TemplateStringsArray} strings\n * @param {(String | Number | Boolean | undefined)[]} keys\n * @returns {string}\n */\nexport const css = (strings, ...keys) => {\n  const stylesheet = strings.reduce(\n    /**\n     * @param {String[]} prev\n     * @param {String} curr\n     * @returns {String[]}\n     */\n    (prev, curr, i) => {\n      prev.push(curr)\n      prev.push(keys?.[i]?.toString() || '')\n      return prev\n    },\n    []\n  ).join('')\n\n  // The implementation of this is lifted from https://github.com/samthor/scoped with some modifications\n  const attrRe = /^\\[.*?(?:([\"'])(?:.|\\\\\\1)*\\1.*)*\\]/\n  const walkSelectorRe = /([([,]|:scope\\b)/ // \"interesting\" setups\n  const scopeRe = /^:scope\\b/\n\n  /**\n   * Consumes a single selector from candidate selector text, which may contain many.\n   *\n   * @param {string} raw selector text\n   * @param {string} prefix prefix to apply\n   * @return {?{selector: string, rest: string}}\n   */\n  function consumeSelector (raw, prefix) {\n    let i = raw.search(walkSelectorRe)\n    if (i === -1) {\n      // found literally nothing interesting, success\n      return {\n        selector: `${prefix} ${raw}`,\n        rest: ''\n      }\n    } else if (raw[i] === ',') {\n      // found comma without anything interesting, yield rest\n      return {\n        selector: `${prefix} ${raw.substring(0, i)}`,\n        rest: raw.substring(i + 1)\n      }\n    }\n\n    let leftmost = true // whether we're past a descendant or similar selector\n    let scope = false // whether :scope has been found + replaced\n    i = raw.search(/\\S/) // place i after initial whitespace only\n\n    let depth = 0\n    // eslint-disable-next-line no-labels\n    outer:\n    for (; i < raw.length; ++i) {\n      const char = raw[i]\n      switch (char) {\n        case '[': {\n          const match = attrRe.exec(raw.substring(i))\n          i += (match ? match[0].length : 1) - 1 // we add 1 every loop\n          continue\n        }\n        case '(':\n          ++depth\n          continue\n        case ':':\n          if (!leftmost) {\n            continue // doesn't matter if :scope is here, it'll always be ignored\n          } else if (!scopeRe.test(raw.substring(i))) {\n            continue // not ':scope', ignore\n          } else if (depth) {\n            return null\n          }\n          // Replace ':scope' with our prefix. This can happen many times; ':scope:scope' is valid.\n          // It will never apply to a descendant selector (e.g., \".foo :scope\") as this is ignored\n          // by browsers anyway (invalid).\n          raw = raw.substring(0, i) + prefix + raw.substring(i + 6)\n          i += prefix.length\n          scope = true\n          --i // we'd skip over next character otherwise\n          continue // run loop again\n        case ')':\n          if (depth) {\n            --depth\n          }\n          continue\n      }\n      if (depth) {\n        continue\n      }\n\n      switch (char) {\n        case ',':\n          // eslint-disable-next-line no-labels\n          break outer\n        case ' ':\n        case '>':\n        case '~':\n        case '+':\n          if (!leftmost) {\n            continue\n          }\n          leftmost = false\n      }\n    }\n\n    const selector = (scope ? '' : `${prefix} `) + raw.substring(0, i)\n    return { selector, rest: raw.substring(i + 1) }\n  }\n\n  /**\n   * @param {string} selectorText\n   * @param {string} prefix to apply\n   */\n  function updateSelectorText (selectorText, prefix) {\n    const found = []\n\n    while (selectorText) {\n      const consumed = consumeSelector(selectorText, prefix)\n      if (consumed === null) {\n        return ':not(*)'\n      }\n      found.push(consumed.selector)\n      selectorText = consumed.rest\n    }\n\n    return found.join(', ')\n  }\n\n  /**\n   * Upgrades a specific CSSRule.\n   *\n   * @param {!CSSRule} rule\n   * @param {string} prefix to apply\n   */\n  function upgradeRule (rule, prefix) {\n    if (rule instanceof CSSMediaRule) {\n      // upgrade children\n      const l = rule.cssRules.length\n      for (let j = 0; j < l; ++j) {\n        upgradeRule(rule.cssRules[j], prefix)\n      }\n      return\n    }\n\n    if (!(rule instanceof CSSStyleRule)) {\n      return // unknown rule type, ignore\n    }\n\n    rule.selectorText = updateSelectorText(rule.selectorText, prefix)\n  }\n  const scope = hash(stylesheet)\n  const retval = `skruv-css-scope-${scope}`\n  const prefix = `.${retval}`\n\n  if (styleMap.has(scope)) {\n    return retval\n  }\n  let sheet\n  // @ts-ignore TODO: If we don't have any way to parse the css bail out\n  if (!globalThis?.CSSOM && !globalThis.document?.implementation) {\n    throw new Error('No css parser available. Either add CSSOM to globalThis or run in browser.')\n  }\n  // @ts-ignore: TODO: Type confusion between polyfill and native.\n  if (globalThis?.CSSOM) {\n    // @ts-ignore: TODO: Type confusion between polyfill and native.\n    sheet = CSSOM.parse(stylesheet)\n  } else {\n    // In FF/Chrome we could create the sheet with new CSSStyleSheet(), but that does not work in safari (supported from 16.4 (Released 2023-03-27))\n    // TODO: don't recreate each run\n    const styleDoc = globalThis.document.implementation.createHTMLDocument('')\n    const styleElem = styleDoc.createElement('style')\n    styleElem.innerText = stylesheet\n    styleDoc.body.append(styleElem)\n    sheet = styleElem.sheet\n    styleDoc.body.removeChild(styleElem)\n  }\n  Array.from(sheet?.cssRules || []).forEach(e =>\n    // @ts-ignore: TODO: Type confusion between polyfill and native.\n    upgradeRule(e, prefix)\n  )\n  const upgradedStyles = Array.from(sheet?.cssRules || []).map(e =>\n    e.cssText || ''\n  )\n    .join('')\n  styleMap.set(scope, upgradedStyles)\n  resolveStyles()\n  return retval\n}\n\n/**\n * @returns {AsyncGenerator<string>}\n */\nexport async function * cssTextGenerator () {\n  yield Array.from(styleMap.values()).join('')\n  while (true) {\n    await promiseStyles\n    yield Array.from(styleMap.values()).join('')\n    promiseStyles = new Promise(resolve => { resolveStyles = resolve })\n  }\n}\n", "// @ts-nocheck\n// TODO: This file will be hard to typecheck without generic types, check how to do it with TS later\nconst resolveTimer = globalThis?.requestAnimationFrame || (cb => setTimeout(cb, 0))\n\nexport const createState = stateObj => {\n  const Handler = class Handler {\n    constructor (name) {\n      this.name = name\n      this._scheduled = false\n      this._skruv_promise = new Promise(resolve => { this._skruv_resolve = resolve })\n    }\n\n    _resolve () {\n      if (this._skruv_parent && this._skruv_parent._resolve) {\n        this._skruv_parent._resolve()\n      }\n      if (this._scheduled) { return }\n      this._scheduled = true\n      resolveTimer(() => {\n        this._skruv_resolve()\n        this._skruv_promise = new Promise(resolve => { this._skruv_resolve = resolve })\n        this._scheduled = false\n      })\n    }\n\n    set (target, key, value) {\n      if (key === '_skruv_parent') {\n        this._skruv_parent = value\n        return true\n      }\n      if (target[key] !== value) {\n        target[key] = this.recurse(key, value, target)\n      }\n      return true\n    }\n\n    get (target, key, proxy) {\n      if (key === 'getGenerator') {\n        return key => ({\n          key: [key, target],\n          [Symbol.asyncIterator]: () => {\n            // If this is the first loop for this sub we should return directly for first value\n            let booted = false\n            return {\n              next: async () => {\n                if (booted) {\n                  await this._skruv_promise\n                } else {\n                  booted = true\n                }\n                return { done: false, value: proxy[key] }\n              }\n            }\n          }\n        })\n      }\n      if (key === 'skruv_resolve') {\n        return () => this._resolve()\n      }\n      if (key === 'toJSON') {\n        if (target.constructor === Object) {\n          return Object.getOwnPropertyNames(target).reduce((acc, curr) => {\n            acc[curr] = target[curr]?.toJSON || target[curr]\n            return acc\n          }, {})\n        }\n        if (target.constructor === Array) {\n          return target.map(curr => curr?.toJSON || curr)\n        }\n        return target\n      }\n      if (key === Symbol.asyncIterator) {\n        return () => {\n          // If this is the first loop for this sub we should return directly for first value\n          let booted = false\n          return {\n            next: async () => {\n              if (booted) {\n                await this._skruv_promise\n              } else {\n                booted = true\n              }\n              return { done: false, value: proxy }\n            }\n          }\n        }\n      }\n      return target[key]\n    }\n\n    deleteProperty (target, key) {\n      const res = delete target[key]\n      this._resolve()\n      return res\n    }\n\n    recurse (path, value, target) {\n      // check for falsy values\n      if (value && value.constructor) {\n        if (value.constructor === Object && target?.[path]?.constructor === Object) {\n          for (const key of Object.getOwnPropertyNames(value)) {\n            if (target[path][key] !== value[key]) {\n              target[path][key] = value[key]\n            }\n          }\n          for (const key of Object.getOwnPropertyNames(target[path])\n            .filter(item => !Object.getOwnPropertyNames(value).includes(item))\n          ) {\n            delete target[path][key]\n            this._resolve()\n          }\n          return target[path]\n        } else if (value.constructor === Object) {\n          const subProxy = new this.constructor(`${this.name}.${path}`)\n          // check object properties for other objects or arrays\n          value = Object.keys(value).reduce((acc, key) => {\n            acc[key] = this.recurse(`${path}.${key}`, value[key])\n            if (typeof acc[key] === 'object' && acc[key] !== null) { acc[key]._skruv_parent = subProxy }\n            return acc\n          }, {})\n          value = new Proxy(value, subProxy)\n          value._skruv_parent = this\n          this._resolve()\n        } else if (value.constructor === Array) {\n          const subProxy = new this.constructor(`${this.name}.${path}`)\n          // check arrays for objects or arrays\n          value = value.map((child, key) => {\n            const newValue = this.recurse(`${path}[${key}]`, child)\n            if (typeof newValue === 'object' && newValue !== null) { newValue._skruv_parent = subProxy }\n            return newValue\n          })\n          value = new Proxy(value, subProxy)\n          value._skruv_parent = this\n          this._resolve()\n        } else {\n          this._resolve()\n        }\n      } else {\n        this._resolve()\n      }\n      return value\n    }\n  }\n\n  // create root proxy\n  const rootProxy = new Proxy(stateObj.constructor === Array ? [] : {}, new Handler('root'))\n  Object.assign(rootProxy, stateObj)\n  return rootProxy\n}\n", "/** @typedef {typeof import(\"../index.js\").Vnode} Vnode */\n/** @typedef {typeof import(\"../index.js\").VnodeAtrributes} VnodeAtrributes */\n\nimport { h } from '../index.js'\n\n/**\n * @typedef {Object} JSXAdditionalProperties\n * @property {[Vnode]} [children]\n *\n * @typedef {VnodeAtrributes & JSXAdditionalProperties} JSXAttributes\n */\n\n/**\n * @param {String} str\n * @returns {String}\n */\nconst kebabize = str => str.replace(/[A-Z]+(?![a-z])|[A-Z]/g, ($, ofs) => (ofs ? '-' : '') + $.toLowerCase())\n\nexport const Fragment = '#fragment'\n\n/**\n * @param {String} nodeName\n * @param {JSXAttributes} [attributes={}]\n * @returns {Vnode | [Vnode?]}\n */\nexport const jsx = (nodeName, attributes = {}) => jsxs(nodeName, attributes)\n\n/**\n * @param {String} nodeName\n * @param {JSXAttributes} [attributes={}]\n * @returns {Vnode | [Vnode?]}\n */\nexport const jsxs = (nodeName, attributes = {}) => {\n  if (nodeName === Fragment && attributes.children) { return attributes.children }\n  if (nodeName === Fragment) { return [] }\n  const { children, ...attrs } = attributes\n  Object.keys(attrs).filter(e => e !== kebabize(e))\n    .forEach(e => {\n      attrs[kebabize(e)] = attrs[e]\n      delete attrs[e]\n    })\n  if (attrs['class-name']) {\n    attrs.class = attrs['class-name']\n    delete attrs['class-name']\n  }\n  if (attrs['html-for']) {\n    attrs.for = attrs['html-for']\n    delete attrs['html-for']\n  }\n  if (children) { return h(nodeName, attrs || {}, children) }\n  return h(nodeName, attrs || {})\n}\n", "import { render } from 'skruv'\nimport { css, cssTextGenerator } from 'skruv/utils/css.js'\nimport { createState } from 'skruv/utils/state.js'\n\nconst state = createState({ todos: ['Write todos'] })\n\nconst styles = css`:scope{color:#f1f1f1;background:#0f0f0f}body{max-width:40ch;margin:0 auto}form{display:flex}input{flex:1}a{color:#9b9b9b}`\n\nrender(\n  <html lang=\"en-US\" class={styles}>\n    <head>\n      <title>{state.todos.getGenerator(0)}</title>\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n      <style>{cssTextGenerator}</style>\n    </head>\n    <body>\n      <main>\n        <h1>{state.todos.getGenerator(0)}</h1>\n        <form onsubmit={\n          e => {\n            e.preventDefault()\n            state.todos.unshift(new FormData(e.target).get('todo'))\n            e.target.reset()\n          }\n        }>\n          <input name=\"todo\"></input>\n          <button>New!</button>\n        </form>\n        {async function * () {\n          for await (const currentState of state) {\n            yield (\n              <ol>\n                {currentState.todos.map((todo, i) => (\n                  <li>{todo} <a\n                    href=\"#\"\n                    onclick={\n                      e => {\n                        e.preventDefault()\n                        currentState.todos.splice(i, 1)\n                      }\n                    }\n                  >x</a>\n                  </li>\n                ))}\n              </ol>\n            )\n          }\n        }}\n      </main>\n    </body>\n  </html>\n)\n"],
  "mappings": "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",
  "names": ["s", "p", "generatorResults", "skruvListeners", "keyedNodes", "hydrationResolve", "hydrationPromise", "resolve", "waitingGens", "hydrating", "h", "c", "_a", "_b", "_c", "_d", "_e", "s", "hydrating", "waitingGens", "hydrationResolve", "syncify", "value", "parent", "toVnodes", "process", "result", "flatten", "generatorResults", "val", "recurseVnodes", "skruvDom", "newVnodes", "p", "a", "entry", "key", "renderRecursive", "current", "currentNode", "parentNode", "isSvg", "ownerDocument", "documentElement", "k", "listeners", "skruvListeners", "curr", "event", "prev", "newOrder", "comp", "ci", "inPrev", "keyedNodes", "toRemove", "elem", "e", "i", "child", "created", "nodeToMove", "newChild", "childNode", "render", "hydrationPromise", "proxyBase", "htmlFactory", "_target", "name", "resolveStyles", "promiseStyles", "resolve", "styleMap", "hash", "str", "css", "strings", "keys", "_a", "stylesheet", "prev", "curr", "i", "attrRe", "walkSelectorRe", "scopeRe", "consumeSelector", "raw", "prefix", "leftmost", "scope", "depth", "outer", "char", "match", "updateSelectorText", "selectorText", "found", "consumed", "upgradeRule", "rule", "l", "j", "retval", "sheet", "styleDoc", "styleElem", "e", "upgradedStyles", "cssTextGenerator", "resolveTimer", "cb", "createState", "stateObj", "Handler", "name", "resolve", "target", "key", "value", "proxy", "booted", "acc", "curr", "_a", "res", "path", "item", "subProxy", "child", "newValue", "rootProxy", "kebabize", "str", "$", "ofs", "Fragment", "jsx", "nodeName", "attributes", "jsxs", "children", "attrs", "e", "h", "state", "createState", "styles", "css", "render", "jsxs", "jsx", "cssTextGenerator", "e", "currentState", "todo"]
}
